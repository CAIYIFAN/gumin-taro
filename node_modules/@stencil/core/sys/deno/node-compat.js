function fromHexChar(e) {
 if (48 <= e && e <= 57) return e - 48;
 if (97 <= e && e <= 102) return e - 97 + 10;
 if (65 <= e && e <= 70) return e - 65 + 10;
 throw function t(e) {
  return new Error("encoding/hex: invalid byte: " + (new TextDecoder).decode(new Uint8Array([ e ])));
 }(e);
}

function notImplemented(e) {
 throw new Error(e ? "Not implemented: " + e : "Not implemented");
}

function normalizeEncoding(e) {
 return null == e || "utf8" === e || "utf-8" === e ? "utf8" : function t(e) {
  switch (e.length) {
  case 4:
   if ("UTF8" === e) return "utf8";
   if ("ucs2" === e || "UCS2" === e) return "utf16le";
   if ("utf8" === (e = ("" + e).toLowerCase())) return "utf8";
   if ("ucs2" === e) return "utf16le";
   break;

  case 3:
   if ("hex" === e || "HEX" === e || "hex" === ("" + e).toLowerCase()) return "hex";
   break;

  case 5:
   if ("ascii" === e) return "ascii";
   if ("ucs-2" === e) return "utf16le";
   if ("UTF-8" === e) return "utf8";
   if ("ASCII" === e) return "ascii";
   if ("UCS-2" === e) return "utf16le";
   if ("utf-8" === (e = ("" + e).toLowerCase())) return "utf8";
   if ("ascii" === e) return "ascii";
   if ("ucs-2" === e) return "utf16le";
   break;

  case 6:
   if ("base64" === e) return "base64";
   if ("latin1" === e || "binary" === e) return "latin1";
   if ("BASE64" === e) return "base64";
   if ("LATIN1" === e || "BINARY" === e) return "latin1";
   if ("base64" === (e = ("" + e).toLowerCase())) return "base64";
   if ("latin1" === e || "binary" === e) return "latin1";
   break;

  case 7:
   if ("utf16le" === e || "UTF16LE" === e || "utf16le" === ("" + e).toLowerCase()) return "utf16le";
   break;

  case 8:
   if ("utf-16le" === e || "UTF-16LE" === e || "utf-16le" === ("" + e).toLowerCase()) return "utf16le";
   break;

  default:
   if ("" === e) return "utf8";
  }
 }(e);
}

function validateIntegerRange(e, t, n = -2147483648, r = 2147483647) {
 if (!Number.isInteger(e)) throw new Error(`${t} must be 'an integer' but was ${e}`);
 if (e < n || e > r) throw new Error(`${t} must be >= ${n} && <= ${r}. Value was ${e}`);
}

function checkEncoding(e = "utf8", t = !0) {
 if ("string" != typeof e || t && "" === e) {
  if (!t) return "utf8";
  throw new TypeError("Unkown encoding: " + e);
 }
 const n = normalizeEncoding(e);
 if (void 0 === n) throw new TypeError("Unkown encoding: " + e);
 return notImplementedEncodings.includes(e) && notImplemented(`"${e}" encoding`), 
 n;
}

function assert(e, t = "") {
 if (!e) throw new DenoStdInternalError(t);
}

function createIterResult(e, t) {
 return {
  value: e,
  done: t
 };
}

function isFileOptions(e) {
 return !!e && (null != e.encoding || null != e.flag || null != e.mode);
}

function getEncoding(e) {
 if (!e || "function" == typeof e) return null;
 return ("string" == typeof e ? e : e.encoding) || null;
}

function checkEncoding$1(e) {
 if (!e) return null;
 if (e = e.toLowerCase(), [ "utf8", "hex", "base64" ].includes(e)) return e;
 if ("utf-8" === e) return "utf8";
 if ("binary" === e) return "binary";
 throw [ "utf16le", "latin1", "ascii", "ucs2" ].includes(e) && notImplemented(`"${e}" encoding`), 
 new Error(`The value "${e}" is invalid for option "encoding"`);
}

function getOpenOptions(e) {
 if (!e) return {
  create: !0,
  append: !0
 };
 let t;
 switch (e) {
 case "a":
  t = {
   create: !0,
   append: !0
  };
  break;

 case "ax":
  t = {
   createNew: !0,
   write: !0,
   append: !0
  };
  break;

 case "a+":
  t = {
   read: !0,
   create: !0,
   append: !0
  };
  break;

 case "ax+":
  t = {
   read: !0,
   createNew: !0,
   append: !0
  };
  break;

 case "r":
  t = {
   read: !0
  };
  break;

 case "r+":
  t = {
   read: !0,
   write: !0
  };
  break;

 case "w":
  t = {
   create: !0,
   write: !0,
   truncate: !0
  };
  break;

 case "wx":
  t = {
   createNew: !0,
   write: !0
  };
  break;

 case "w+":
  t = {
   create: !0,
   write: !0,
   truncate: !0,
   read: !0
  };
  break;

 case "wx+":
  t = {
   createNew: !0,
   write: !0,
   read: !0
  };
  break;

 case "as":
  t = {
   create: !0,
   append: !0
  };
  break;

 case "as+":
  t = {
   create: !0,
   read: !0,
   append: !0
  };
  break;

 case "rs+":
  t = {
   create: !0,
   read: !0,
   write: !0
  };
  break;

 default:
  throw new Error("Unrecognized file system flag: " + e);
 }
 return t;
}

function assertPath(e) {
 if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
}

function isPosixPathSeparator(e) {
 return 47 === e;
}

function isPathSeparator(e) {
 return isPosixPathSeparator(e) || 92 === e;
}

function isWindowsDeviceRoot(e) {
 return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}

function normalizeString(e, t, n, r) {
 let o, i = "", s = 0, a = -1, l = 0;
 for (let c = 0, u = e.length; c <= u; ++c) {
  if (c < u) o = e.charCodeAt(c); else {
   if (r(o)) break;
   o = 47;
  }
  if (r(o)) {
   if (a === c - 1 || 1 === l) ; else if (a !== c - 1 && 2 === l) {
    if (i.length < 2 || 2 !== s || 46 !== i.charCodeAt(i.length - 1) || 46 !== i.charCodeAt(i.length - 2)) {
     if (i.length > 2) {
      const e = i.lastIndexOf(n);
      -1 === e ? (i = "", s = 0) : (i = i.slice(0, e), s = i.length - 1 - i.lastIndexOf(n)), 
      a = c, l = 0;
      continue;
     }
     if (2 === i.length || 1 === i.length) {
      i = "", s = 0, a = c, l = 0;
      continue;
     }
    }
    t && (i.length > 0 ? i += n + ".." : i = "..", s = 2);
   } else i.length > 0 ? i += n + e.slice(a + 1, c) : i = e.slice(a + 1, c), s = c - a - 1;
   a = c, l = 0;
  } else 46 === o && -1 !== l ? ++l : l = -1;
 }
 return i;
}

function _format(e, t) {
 const n = t.dir || t.root, r = t.base || (t.name || "") + (t.ext || "");
 return n ? n === t.root ? n + r : n + e + r : r;
}

function resolve(...e) {
 let t = "", n = "", r = !1;
 for (let o = e.length - 1; o >= -1; o--) {
  let i;
  if (o >= 0) i = e[o]; else if (t) {
   if (null == globalThis.Deno) throw new TypeError("Resolved a relative path without a CWD.");
   i = Deno.env.get("=" + t) || Deno.cwd(), void 0 !== i && i.slice(0, 3).toLowerCase() === t.toLowerCase() + "\\" || (i = t + "\\");
  } else {
   if (null == globalThis.Deno) throw new TypeError("Resolved a drive-letter-less path without a CWD.");
   i = Deno.cwd();
  }
  assertPath(i);
  const s = i.length;
  if (0 === s) continue;
  let a = 0, l = "", c = !1;
  const u = i.charCodeAt(0);
  if (s > 1) if (isPathSeparator(u)) if (c = !0, isPathSeparator(i.charCodeAt(1))) {
   let e = 2, t = e;
   for (;e < s && !isPathSeparator(i.charCodeAt(e)); ++e) ;
   if (e < s && e !== t) {
    const n = i.slice(t, e);
    for (t = e; e < s && isPathSeparator(i.charCodeAt(e)); ++e) ;
    if (e < s && e !== t) {
     for (t = e; e < s && !isPathSeparator(i.charCodeAt(e)); ++e) ;
     e === s ? (l = `\\\\${n}\\${i.slice(t)}`, a = e) : e !== t && (l = `\\\\${n}\\${i.slice(t, e)}`, 
     a = e);
    }
   }
  } else a = 1; else isWindowsDeviceRoot(u) && 58 === i.charCodeAt(1) && (l = i.slice(0, 2), 
  a = 2, s > 2 && isPathSeparator(i.charCodeAt(2)) && (c = !0, a = 3)); else isPathSeparator(u) && (a = 1, 
  c = !0);
  if (!(l.length > 0 && t.length > 0 && l.toLowerCase() !== t.toLowerCase()) && (0 === t.length && l.length > 0 && (t = l), 
  r || (n = `${i.slice(a)}\\${n}`, r = c), r && t.length > 0)) break;
 }
 return n = normalizeString(n, !r, "\\", isPathSeparator), t + (r ? "\\" : "") + n || ".";
}

function normalize(e) {
 assertPath(e);
 const t = e.length;
 if (0 === t) return ".";
 let n, r = 0, o = !1;
 const i = e.charCodeAt(0);
 if (t > 1) if (isPathSeparator(i)) if (o = !0, isPathSeparator(e.charCodeAt(1))) {
  let o = 2, i = o;
  for (;o < t && !isPathSeparator(e.charCodeAt(o)); ++o) ;
  if (o < t && o !== i) {
   const s = e.slice(i, o);
   for (i = o; o < t && isPathSeparator(e.charCodeAt(o)); ++o) ;
   if (o < t && o !== i) {
    for (i = o; o < t && !isPathSeparator(e.charCodeAt(o)); ++o) ;
    if (o === t) return `\\\\${s}\\${e.slice(i)}\\`;
    o !== i && (n = `\\\\${s}\\${e.slice(i, o)}`, r = o);
   }
  }
 } else r = 1; else isWindowsDeviceRoot(i) && 58 === e.charCodeAt(1) && (n = e.slice(0, 2), 
 r = 2, t > 2 && isPathSeparator(e.charCodeAt(2)) && (o = !0, r = 3)); else if (isPathSeparator(i)) return "\\";
 let s;
 return s = r < t ? normalizeString(e.slice(r), !o, "\\", isPathSeparator) : "", 
 0 !== s.length || o || (s = "."), s.length > 0 && isPathSeparator(e.charCodeAt(t - 1)) && (s += "\\"), 
 void 0 === n ? o ? s.length > 0 ? "\\" + s : "\\" : s.length > 0 ? s : "" : o ? s.length > 0 ? `${n}\\${s}` : n + "\\" : s.length > 0 ? n + s : n;
}

function resolve$1(...e) {
 let t = "", n = !1;
 for (let r = e.length - 1; r >= -1 && !n; r--) {
  let o;
  if (r >= 0) o = e[r]; else {
   if (null == globalThis.Deno) throw new TypeError("Resolved a relative path without a CWD.");
   o = Deno.cwd();
  }
  assertPath(o), 0 !== o.length && (t = `${o}/${t}`, n = 47 === o.charCodeAt(0));
 }
 return t = normalizeString(t, !n, "/", isPosixPathSeparator), n ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : ".";
}

function normalize$1(e) {
 if (assertPath(e), 0 === e.length) return ".";
 const t = 47 === e.charCodeAt(0), n = 47 === e.charCodeAt(e.length - 1);
 return 0 !== (e = normalizeString(e, !t, "/", isPosixPathSeparator)).length || t || (e = "."), 
 e.length > 0 && n && (e += "/"), t ? "/" + e : e;
}

function normalizeGlob(e, {globstar: t = !1} = {}) {
 if (e.match(/\0/g)) throw new Error(`Glob contains invalid characters: "${e}"`);
 if (!t) return normalize$2(e);
 const n = SEP_PATTERN.source, r = new RegExp(`(?<=(${n}|^)\\*\\*${n})\\.\\.(?=${n}|$)`, "g");
 return normalize$2(e.replace(r, "\0")).replace(/\0/g, "..");
}

function closeRidIfNecessary(e, t) {
 e && -1 != t && Deno.close(t);
}

function validateEncoding(e) {
 if (e) if ("string" == typeof e) {
  if ("utf8" !== e) throw new Error("Only 'utf8' encoding is currently supported");
 } else if (e.encoding && "utf8" !== e.encoding) throw new Error("Only 'utf8' encoding is currently supported");
}

function getResolvedMode(e) {
 if ("number" == typeof e) return e;
 if ("string" == typeof e && !allowedModes.test(e)) throw new Error("Unrecognized mode: " + e);
 return parseInt(e, 8);
}

function maybeDecode(e, t) {
 const n = new Buffer(e.buffer, e.byteOffset, e.byteLength);
 return t && "binary" !== t ? n.toString(t) : n;
}

function readFile(e, t, n) {
 let r;
 e = e instanceof URL ? fromFileUrl$2(e) : e, r = "function" == typeof t ? t : n;
 const o = getEncoding(t), i = Deno.readFile(e);
 r && i.then(e => {
  if (o && "binary" !== o) {
   const t = maybeDecode(e, o);
   return r(null, t);
  }
  const t = maybeDecode(e, o);
  r(null, t);
 }).catch(e => r && r(e));
}

function maybeEncode(e, t) {
 return "buffer" === t ? (new TextEncoder).encode(e) : e;
}

function getEncoding$1(e) {
 if (e && "function" != typeof e) {
  if (e.encoding) {
   if ("utf8" === e.encoding || "utf-8" === e.encoding) return "utf8";
   if ("buffer" === e.encoding) return "buffer";
   notImplemented();
  }
  return null;
 }
 return null;
}

function writeFile(e, t, n, r) {
 const o = n instanceof Function ? n : r, i = n instanceof Function ? void 0 : n;
 if (!o) throw new TypeError("Callback must be a function.");
 e = e instanceof URL ? fromFileUrl$2(e) : e;
 const s = isFileOptions(i) ? i.flag : void 0, a = isFileOptions(i) ? i.mode : void 0, l = checkEncoding$1(getEncoding(i)) || "utf8", c = getOpenOptions(s || "w");
 "string" == typeof t && (t = Buffer.from(t, l));
 const u = "number" == typeof e;
 let f, d = null;
 (async () => {
  try {
   f = u ? new Deno.File(e) : await Deno.open(e, c), !u && a && ("windows" === Deno.build.os && notImplemented('"mode" on Windows'), 
   await Deno.chmod(e, a)), await Deno.writeAll(f, t);
  } catch (e) {
   d = e;
  } finally {
   !u && f && f.close(), o(d);
  }
 })();
}

function toDirent(e) {
 return new Dirent(e);
}

function decode$2(e, t) {
 if (t) {
  const n = new TextDecoder(t), r = new TextEncoder;
  return n.decode(r.encode(e));
 }
 return e;
}

function existsSync$1(e) {
 try {
  return Deno.lstatSync(e), !0;
 } catch (e) {
  if (e instanceof Deno.errors.NotFound) return !1;
  throw e;
 }
}

function convertFlagAndModeToOptions(e, t) {
 if (e || t) return !e && t ? {
  mode: t
 } : {
  ...getOpenOptions(e),
  mode: t
 };
}

function openSync(e, t, n) {
 const r = "string" == typeof t ? t : void 0, o = "number" == typeof t ? t : n;
 if (e = e instanceof URL ? fromFileUrl$2(e) : e, [ "ax", "ax+", "wx", "wx+" ].includes(r || "") && existsSync$1(e)) throw new Error(`EEXIST: file already exists, open '${e}'`);
 return Deno.openSync(e, convertFlagAndModeToOptions(r, o)).rid;
}

function CFISBIS(e, t) {
 return t ? function n(e) {
  return {
   dev: BigInt(e.dev),
   ino: BigInt(e.ino),
   mode: BigInt(e.mode),
   nlink: BigInt(e.nlink),
   uid: BigInt(e.uid),
   gid: BigInt(e.gid),
   rdev: BigInt(e.rdev),
   size: BigInt(e.size),
   blksize: BigInt(e.blksize),
   blocks: BigInt(e.blocks),
   mtime: e.mtime,
   atime: e.atime,
   birthtime: e.birthtime,
   mtimeMs: e.mtime ? BigInt(e.mtime.getTime()) : null,
   atimeMs: e.atime ? BigInt(e.atime.getTime()) : null,
   birthtimeMs: e.birthtime ? BigInt(e.birthtime.getTime()) : null,
   mtimeNs: e.mtime ? 1000000n * BigInt(e.mtime.getTime()) : null,
   atimeNs: e.atime ? 1000000n * BigInt(e.atime.getTime()) : null,
   birthtimeNs: e.birthtime ? 1000000n * BigInt(e.birthtime.getTime()) : null,
   isFile: () => e.isFile,
   isDirectory: () => e.isDirectory,
   isSymbolicLink: () => e.isSymlink,
   isBlockDevice: () => !1,
   isFIFO: () => !1,
   isCharacterDevice: () => !1,
   isSocket: () => !1,
   ctime: e.mtime,
   ctimeMs: e.mtime ? BigInt(e.mtime.getTime()) : null,
   ctimeNs: e.mtime ? 1000000n * BigInt(e.mtime.getTime()) : null
  };
 }(e) : function r(e) {
  var t, n, r, o;
  return {
   dev: e.dev,
   ino: e.ino,
   mode: e.mode,
   nlink: e.nlink,
   uid: e.uid,
   gid: e.gid,
   rdev: e.rdev,
   size: e.size,
   blksize: e.blksize,
   blocks: e.blocks,
   mtime: e.mtime,
   atime: e.atime,
   birthtime: e.birthtime,
   mtimeMs: (null === (t = e.mtime) || void 0 === t ? void 0 : t.getTime()) || null,
   atimeMs: (null === (n = e.atime) || void 0 === n ? void 0 : n.getTime()) || null,
   birthtimeMs: (null === (r = e.birthtime) || void 0 === r ? void 0 : r.getTime()) || null,
   isFile: () => e.isFile,
   isDirectory: () => e.isDirectory,
   isSymbolicLink: () => e.isSymlink,
   isBlockDevice: () => !1,
   isFIFO: () => !1,
   isCharacterDevice: () => !1,
   isSocket: () => !1,
   ctime: e.mtime,
   ctimeMs: (null === (o = e.mtime) || void 0 === o ? void 0 : o.getTime()) || null
  };
 }(e);
}

function arch$1() {
 return Deno.build.arch;
}

function endianness() {
 const e = new ArrayBuffer(2);
 return new DataView(e).setInt16(0, 256, !0), 256 === new Int16Array(e)[0] ? "LE" : "BE";
}

function freemem() {
 notImplemented(SEE_GITHUB_ISSUE);
}

function homedir() {
 notImplemented(SEE_GITHUB_ISSUE);
}

function hostname() {
 notImplemented(SEE_GITHUB_ISSUE);
}

function platform$1() {
 return process.platform;
}

function release() {
 return Deno.osRelease();
}

function totalmem() {
 notImplemented(SEE_GITHUB_ISSUE);
}

function type() {
 notImplemented(SEE_GITHUB_ISSUE);
}

function uptime() {
 notImplemented(SEE_GITHUB_ISSUE);
}

function parse$3(e, t = "&", n = "=", {decodeURIComponent: r = unescape, maxKeys: o = 1e3} = {}) {
 const i = e.split(t).map(e => e.split(n).map(r)), s = {};
 let a = 0;
 for (;(Object.keys(s).length !== o || !o) && i[a]; ) {
  const [e, t] = i[a];
  s[e] ? Array.isArray(s[e]) ? s[e].push(t) : s[e] = [ s[e], t ] : s[e] = t, a++;
 }
 return s;
}

function stringify(e, t = "&", n = "=", {encodeURIComponent: r = escape} = {}) {
 const o = [];
 for (const t of Object.entries(e)) if (Array.isArray(t[1])) for (const e of t[1]) o.push(r(t[0]) + n + r(e)); else "object" != typeof t[1] && void 0 !== t[1] ? o.push(t.map(r).join(n)) : o.push(r(t[0]) + n);
 return o.join(t);
}

function normalizeEncoding$1(e) {
 const t = normalizeEncoding(null != e ? e : null);
 if (t && t in NotImplemented && notImplemented(t), !t && "string" == typeof e && "raw" !== e.toLowerCase()) throw new Error("Unknown encoding: " + e);
 return String(t);
}

function utf8CheckByte(e) {
 return e <= 127 ? 0 : e >> 5 == 6 ? 2 : e >> 4 == 14 ? 3 : e >> 3 == 30 ? 4 : e >> 6 == 2 ? -1 : -2;
}

function utf8FillLastComplete(e) {
 const t = this.lastTotal - this.lastNeed, n = function r(e, t) {
  if (128 != (192 & t[0])) return e.lastNeed = 0, "�";
  if (e.lastNeed > 1 && t.length > 1) {
   if (128 != (192 & t[1])) return e.lastNeed = 1, "�";
   if (e.lastNeed > 2 && t.length > 2 && 128 != (192 & t[2])) return e.lastNeed = 2, 
   "�";
  }
 }(this, e);
 return void 0 !== n ? n : this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), 
 this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e.copy(this.lastChar, t, 0, e.length), 
 void (this.lastNeed -= e.length));
}

function utf8FillLastIncomplete(e) {
 if (this.lastNeed <= e.length) return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), 
 this.lastChar.toString(this.encoding, 0, this.lastTotal);
 e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
}

function utf8Text(e, t) {
 const n = function r(e, t, n) {
  let r = t.length - 1;
  if (r < n) return 0;
  let o = utf8CheckByte(t[r]);
  return o >= 0 ? (o > 0 && (e.lastNeed = o - 1), o) : --r < n || -2 === o ? 0 : (o = utf8CheckByte(t[r]), 
  o >= 0 ? (o > 0 && (e.lastNeed = o - 2), o) : --r < n || -2 === o ? 0 : (o = utf8CheckByte(t[r]), 
  o >= 0 ? (o > 0 && (2 === o ? o = 0 : e.lastNeed = o - 3), o) : 0));
 }(this, e, t);
 if (!this.lastNeed) return e.toString("utf8", t);
 this.lastTotal = n;
 const o = e.length - (n - this.lastNeed);
 return e.copy(this.lastChar, 0, o), e.toString("utf8", t, o);
}

function utf8End(e) {
 const t = e && e.length ? this.write(e) : "";
 return this.lastNeed ? t + "�" : t;
}

function utf8Write(e) {
 if (0 === e.length) return "";
 let t, n;
 if (this.lastNeed) {
  if (t = this.fillLast(e), void 0 === t) return "";
  n = this.lastNeed, this.lastNeed = 0;
 } else n = 0;
 return n < e.length ? t ? t + this.text(e, n) : this.text(e, n) : t || "";
}

function base64Text(e, t) {
 const n = (e.length - t) % 3;
 return 0 === n ? e.toString("base64", t) : (this.lastNeed = 3 - n, this.lastTotal = 3, 
 1 === n ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], 
 this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - n));
}

function base64End(e) {
 const t = e && e.length ? this.write(e) : "";
 return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}

function simpleWrite(e) {
 return e.toString(this.encoding);
}

function simpleEnd(e) {
 return e && e.length ? this.write(e) : "";
}

function promisify(e) {
 function t(...t) {
  return new Promise((r, o) => {
   e.call(this, ...t, (e, ...t) => {
    if (e) return o(e);
    if (void 0 !== n && t.length > 1) {
     const e = {};
     for (let r = 0; r < n.length; r++) e[n[r]] = t[r];
     r(e);
    } else r(t[0]);
   });
  });
 }
 if ("function" != typeof e) throw new NodeInvalidArgTypeError("original", "Function", e);
 if (e[kCustomPromisifiedSymbol]) {
  const t = e[kCustomPromisifiedSymbol];
  if ("function" != typeof t) throw new NodeInvalidArgTypeError("util.promisify.custom", "Function", t);
  return Object.defineProperty(t, kCustomPromisifiedSymbol, {
   value: t,
   enumerable: !1,
   writable: !1,
   configurable: !0
  });
 }
 const n = e[kCustomPromisifyArgsSymbol];
 return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Object.defineProperty(t, kCustomPromisifiedSymbol, {
  value: t,
  enumerable: !1,
  writable: !1,
  configurable: !0
 }), Object.defineProperties(t, Object.getOwnPropertyDescriptors(e));
}

function isBooleanObject(e) {
 return _isObjectLike(e) && "[object Boolean]" === _toString.call(e);
}

function isNumberObject(e) {
 return _isObjectLike(e) && "[object Number]" === _toString.call(e);
}

function isBigIntObject(e) {
 return _isObjectLike(e) && "[object BigInt]" === _toString.call(e);
}

function isStringObject(e) {
 return _isObjectLike(e) && "[object String]" === _toString.call(e);
}

function isSymbolObject(e) {
 return _isObjectLike(e) && "[object Symbol]" === _toString.call(e);
}

function inspect(e, ...t) {
 return t = {
  ...DEFAULT_INSPECT_OPTIONS,
  ...t
 }, Deno.inspect(e, {
  depth: t.depth,
  iterableLimit: t.maxArrayLength,
  compact: !!t.compact,
  sorted: !!t.sorted,
  showProxy: !!t.showProxy
 });
}

function fileURLToPath(e) {
 if ("string" == typeof e) e = new URL(e); else if (!(e instanceof URL)) throw new Deno.errors.InvalidData("invalid argument path , must be a string or URL");
 if ("file:" !== e.protocol) throw new Deno.errors.InvalidData("invalid url scheme");
 return isWindows$1 ? function t(e) {
  const t = e.hostname;
  let n = e.pathname;
  for (let e = 0; e < n.length; e++) if ("%" === n[e]) {
   const t = n.codePointAt(e + 2) || 32;
   if ("2" === n[e + 1] && 102 === t || "5" === n[e + 1] && 99 === t) throw new Deno.errors.InvalidData("must not include encoded \\ or / characters");
  }
  if (n = n.replace(forwardSlashRegEx, "\\"), n = decodeURIComponent(n), "" !== t) return `\\\\${t}${n}`;
  {
   const e = 32 | n.codePointAt(1), t = n[2];
   if (e < 97 || e > 122 || ":" !== t) throw new Deno.errors.InvalidData("file url path must be absolute");
   return n.slice(1);
  }
 }(e) : function n(e) {
  if ("" !== e.hostname) throw new Deno.errors.InvalidData("invalid file url hostname");
  const t = e.pathname;
  for (let e = 0; e < t.length; e++) if ("%" === t[e]) {
   const n = t.codePointAt(e + 2) || 32;
   if ("2" === t[e + 1] && 102 === n) throw new Deno.errors.InvalidData("must not include encoded / characters");
  }
  return decodeURIComponent(t);
 }(e);
}

function pathToFileURL(e) {
 let t = resolve$2(e);
 const n = e.charCodeAt(e.length - 1);
 (47 === n || isWindows$1 && 92 === n) && t[t.length - 1] !== sep$2 && (t += "/");
 const r = new URL("file://");
 return t.includes("%") && (t = t.replace(percentRegEx, "%25")), !isWindows$1 && t.includes("\\") && (t = t.replace(backslashRegEx, "%5C")), 
 t.includes("\n") && (t = t.replace(newlineRegEx, "%0A")), t.includes("\r") && (t = t.replace(carriageReturnRegEx, "%0D")), 
 t.includes("\t") && (t = t.replace(tabRegEx, "%09")), r.pathname = t, r;
}

function stat$1(e) {
 if (e = toNamespacedPath$2(e), null !== statCache) {
  const t = statCache.get(e);
  if (void 0 !== t) return t;
 }
 try {
  const t = Deno.statSync(e).isFile ? 0 : 1;
  return null !== statCache && statCache.set(e, t), t;
 } catch (e) {
  if (e instanceof Deno.errors.PermissionDenied) throw new Error("CJS loader requires --allow-read.");
  return -1;
 }
}

function updateChildren(e, t, n) {
 const r = e && e.children;
 !r || n && r.includes(t) || r.push(t);
}

function createNativeModule(e, t) {
 const n = new Module(e);
 return n.exports = t, n.loaded = !0, n;
}

function readPackage(e) {
 const t = resolve$2(e, "package.json"), n = packageJsonCache.get(t);
 if (void 0 !== n) return n;
 let r;
 try {
  r = (new TextDecoder).decode(Deno.readFileSync(toNamespacedPath$2(t)));
 } catch (e) {}
 if (void 0 === r) return packageJsonCache.set(t, null), null;
 try {
  const e = JSON.parse(r), n = {
   name: e.name,
   main: e.main,
   exports: e.exports,
   type: e.type
  };
  return packageJsonCache.set(t, n), n;
 } catch (e) {
  throw e.path = t, e.message = "Error parsing " + t + ": " + e.message, e;
 }
}

function tryPackage(e, t, n, r) {
 const o = function i(e) {
  const t = readPackage(e);
  return t ? t.main : void 0;
 }(e);
 if (!o) return tryExtensions(resolve$2(e, "index"), t);
 const s = resolve$2(e, o);
 let a = tryFile(s) || tryExtensions(s, t) || tryExtensions(resolve$2(s, "index"), t);
 if (!1 === a && (a = tryExtensions(resolve$2(e, "index"), t), !a)) {
  const e = new Error(`Cannot find module '${s}'. Please verify that the package.json has a valid "main" entry`);
  throw e.code = "MODULE_NOT_FOUND", e;
 }
 return a;
}

function tryFile(e, t) {
 return 0 === stat$1(e) && toRealPath(e);
}

function toRealPath(e) {
 let t = e;
 for (;;) try {
  t = Deno.readLinkSync(t);
 } catch (e) {
  break;
 }
 return resolve$2(e);
}

function tryExtensions(e, t, n) {
 for (let n = 0; n < t.length; n++) {
  const r = tryFile(e + t[n]);
  if (r) return r;
 }
 return !1;
}

function resolveExports(e, t, n) {
 if (!n) {
  const [, n, r = ""] = t.match(EXPORTS_PATTERN) || [];
  return n ? function r(e, t) {
   const n = "." + t;
   let r = function o(e) {
    const t = readPackage(e);
    return t ? t.exports : void 0;
   }(e);
   if (null == r) return resolve$2(e, n);
   if (function i(e, t) {
    if ("string" == typeof e) return !0;
    if (Array.isArray(e)) return !0;
    if ("object" != typeof e) return !1;
    let n = !1, r = !0;
    for (const t of Object.keys(e)) {
     const e = "." !== t[0];
     if (r) r = !1, n = e; else if (n !== e) throw new Error("\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.");
    }
    return n;
   }(r) && (r = {
    ".": r
   }), "object" == typeof r) {
    if (Object.prototype.hasOwnProperty.call(r, n)) {
     const t = r[n];
     return resolveExportsTarget(pathToFileURL(e + "/"), t, "", e, n);
    }
    if ("." === n) return e;
    let t = "";
    for (const e of Object.keys(r)) "/" === e[e.length - 1] && e.length > t.length && n.startsWith(e) && (t = e);
    if ("" !== t) {
     const o = r[t], i = n.slice(t.length);
     return resolveExportsTarget(pathToFileURL(e + "/"), o, i, e, n);
    }
   }
   if ("." === n) return e;
   const s = new Error(`Package exports for '${e}' do not define a '${n}' subpath`);
   throw s.code = "MODULE_NOT_FOUND", s;
  }(resolve$2(e, n), r) : resolve$2(e, t);
 }
 return resolve$2(e, t);
}

function resolveExportsTarget(e, t, n, r, o) {
 if ("string" == typeof t) {
  if (t.startsWith("./") && (0 === n.length || t.endsWith("/"))) {
   const r = new URL(t, e), o = e.pathname, i = r.pathname;
   if (i.startsWith(o) && -1 === i.indexOf("/node_modules/", o.length - 1)) {
    const e = new URL(n, r), t = e.pathname;
    if (t.startsWith(i) && -1 === t.indexOf("/node_modules/", o.length - 1)) return fileURLToPath(e);
   }
  }
 } else if (Array.isArray(t)) {
  for (const s of t) if (!Array.isArray(s)) try {
   return resolveExportsTarget(e, s, n, r, o);
  } catch (i) {
   if ("MODULE_NOT_FOUND" !== i.code) throw i;
  }
 } else if ("object" == typeof t && null !== t && Object.prototype.hasOwnProperty.call(t, "default")) try {
  return resolveExportsTarget(e, t.default, n, r, o);
 } catch (i) {
  if ("MODULE_NOT_FOUND" !== i.code) throw i;
 }
 let i;
 throw i = "." !== o ? new Error(`Package exports for '${r}' do not define a valid '${o}' target${n ? " for " + n : ""}`) : new Error(`No valid exports main found for '${r}'`), 
 i.code = "MODULE_NOT_FOUND", i;
}

function emitCircularRequireWarning(e) {
 console.error(`Accessing non-existent property '${String(e)}' of module exports inside circular dependency`);
}

function getExportsForCircularRequire(e) {
 return e.exports && Object.getPrototypeOf(e.exports) === PublicObjectPrototype && !e.exports.__esModule && Object.setPrototypeOf(e.exports, CircularRequirePrototypeWarningProxy), 
 e.exports;
}

function makeRequireFunction(e) {
 function t(t, n) {
  return Module._resolveFilename(t, e, !1, n);
 }
 const n = function t(n) {
  return e.require(n);
 };
 return n.resolve = t, t.paths = function r(t) {
  return Module._resolveLookupPaths(t, e);
 }, n.extensions = Module._extensions, n.cache = Module._cache, n;
}

var _a, _b, _c, EOL, NotImplemented;

const hextable = (new TextEncoder).encode("0123456789abcdef"), _TextDecoder = TextDecoder, _TextEncoder = TextEncoder, notImplementedEncodings = [ "ascii", "binary", "latin1", "ucs2", "utf16le" ], encodingOps = {
 utf8: {
  byteLength: e => (new TextEncoder).encode(e).byteLength
 },
 ucs2: {
  byteLength: e => 2 * e.length
 },
 utf16le: {
  byteLength: e => 2 * e.length
 },
 latin1: {
  byteLength: e => e.length
 },
 ascii: {
  byteLength: e => e.length
 },
 base64: {
  byteLength: e => function t(e, n) {
   return 61 === e.charCodeAt(n - 1) && n--, n > 1 && 61 === e.charCodeAt(n - 1) && n--, 
   3 * n >>> 2;
  }(e, e.length)
 },
 hex: {
  byteLength: e => e.length >>> 1
 }
};

class Buffer extends Uint8Array {
 static alloc(e, t, n = "utf8") {
  if ("number" != typeof e) throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e);
  const r = new Buffer(e);
  if (0 === e) return r;
  let o;
  if ("string" == typeof t) n = checkEncoding(n), "string" == typeof t && 1 === t.length && "utf8" === n ? r.fill(t.charCodeAt(0)) : o = Buffer.from(t, n); else if ("number" == typeof t) r.fill(t); else if (t instanceof Uint8Array) {
   if (0 === t.length) throw new TypeError(`The argument "value" is invalid. Received ${t.constructor.name} []`);
   o = t;
  }
  if (o) {
   o.length > r.length && (o = o.subarray(0, r.length));
   let t = 0;
   for (;t < e && (r.set(o, t), t += o.length, !(t + o.length >= e)); ) ;
   t !== e && r.set(o.subarray(0, e - t), t);
  }
  return r;
 }
 static allocUnsafe(e) {
  return new Buffer(e);
 }
 static byteLength(e, t = "utf8") {
  return "string" != typeof e ? e.byteLength : (t = normalizeEncoding(t) || "utf8", 
  encodingOps[t].byteLength(e));
 }
 static concat(e, t) {
  if (null == t) {
   t = 0;
   for (const n of e) t += n.length;
  }
  const n = new Buffer(t);
  let r = 0;
  for (const t of e) n.set(t, r), r += t.length;
  return n;
 }
 static from(e, t, n) {
  const r = "string" == typeof t ? void 0 : t;
  let o = "string" == typeof t ? t : void 0;
  return "string" == typeof e ? (o = checkEncoding(o, !1), new Buffer("hex" === o ? function i(e) {
   return function t(e) {
    const t = new Uint8Array(function n(e) {
     return e >>> 1;
    }(e.length));
    for (let n = 0; n < t.length; n++) {
     const r = fromHexChar(e[2 * n]), o = fromHexChar(e[2 * n + 1]);
     t[n] = r << 4 | o;
    }
    if (e.length % 2 == 1) throw fromHexChar(e[2 * t.length]), function r() {
     return new Error("encoding/hex: odd length hex string");
    }();
    return t;
   }((new TextEncoder).encode(e));
  }(e).buffer : "base64" === o ? function s(e) {
   const t = function n(e) {
    return atob(e);
   }(e), r = new Uint8Array(t.length);
   for (let e = 0; e < r.length; ++e) r[e] = t.charCodeAt(e);
   return r.buffer;
  }(e) : (new TextEncoder).encode(e).buffer)) : new Buffer(e, r, n);
 }
 static isBuffer(e) {
  return e instanceof Buffer;
 }
 static isEncoding(e) {
  return "string" == typeof e && 0 !== e.length && void 0 !== normalizeEncoding(e);
 }
 copy(e, t = 0, n = 0, r = this.length) {
  const o = this.subarray(n, r);
  return e.set(o, t), o.length;
 }
 equals(e) {
  if (!(e instanceof Uint8Array)) throw new TypeError('The "otherBuffer" argument must be an instance of Buffer or Uint8Array. Received type ' + typeof e);
  if (this === e) return !0;
  if (this.byteLength !== e.byteLength) return !1;
  for (let t = 0; t < this.length; t++) if (this[t] !== e[t]) return !1;
  return !0;
 }
 readBigInt64BE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getBigInt64(e);
 }
 readBigInt64LE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getBigInt64(e, !0);
 }
 readBigUInt64BE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getBigUint64(e);
 }
 readBigUInt64LE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getBigUint64(e, !0);
 }
 readDoubleBE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getFloat64(e);
 }
 readDoubleLE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getFloat64(e, !0);
 }
 readFloatBE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getFloat32(e);
 }
 readFloatLE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getFloat32(e, !0);
 }
 readInt8(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt8(e);
 }
 readInt16BE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt16(e);
 }
 readInt16LE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt16(e, !0);
 }
 readInt32BE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt32(e);
 }
 readInt32LE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getInt32(e, !0);
 }
 readUInt8(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint8(e);
 }
 readUInt16BE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint16(e);
 }
 readUInt16LE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint16(e, !0);
 }
 readUInt32BE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint32(e);
 }
 readUInt32LE(e = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).getUint32(e, !0);
 }
 slice(e = 0, t = this.length) {
  return this.subarray(e, t);
 }
 toJSON() {
  return {
   type: "Buffer",
   data: Array.from(this)
  };
 }
 toString(e = "utf8", t = 0, n = this.length) {
  e = checkEncoding(e);
  const r = this.subarray(t, n);
  return "hex" === e ? function o(e) {
   return (new TextDecoder).decode(function t(e) {
    const t = new Uint8Array(function n(e) {
     return 2 * e;
    }(e.length));
    for (let n = 0; n < t.length; n++) {
     const r = e[n];
     t[2 * n] = hextable[r >> 4], t[2 * n + 1] = hextable[15 & r];
    }
    return t;
   }(e));
  }(r) : "base64" === e ? function i(e) {
   if ("string" == typeof e) return btoa(e);
   {
    const t = new Uint8Array(e);
    let n = "";
    for (let e = 0; e < t.length; ++e) n += String.fromCharCode(t[e]);
    return btoa(n);
   }
  }(r.buffer) : new TextDecoder(e).decode(r);
 }
 write(e, t = 0, n = this.length) {
  return (new TextEncoder).encodeInto(e, this.subarray(t, t + n)).written;
 }
 writeBigInt64BE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setBigInt64(t, e), 
  t + 4;
 }
 writeBigInt64LE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setBigInt64(t, e, !0), 
  t + 4;
 }
 writeBigUInt64BE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setBigUint64(t, e), 
  t + 4;
 }
 writeBigUInt64LE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setBigUint64(t, e, !0), 
  t + 4;
 }
 writeDoubleBE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setFloat64(t, e), 
  t + 8;
 }
 writeDoubleLE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setFloat64(t, e, !0), 
  t + 8;
 }
 writeFloatBE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setFloat32(t, e), 
  t + 4;
 }
 writeFloatLE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setFloat32(t, e, !0), 
  t + 4;
 }
 writeInt8(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setInt8(t, e), 
  t + 1;
 }
 writeInt16BE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setInt16(t, e), 
  t + 2;
 }
 writeInt16LE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setInt16(t, e, !0), 
  t + 2;
 }
 writeInt32BE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setUint32(t, e), 
  t + 4;
 }
 writeInt32LE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setInt32(t, e, !0), 
  t + 4;
 }
 writeUInt8(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setUint8(t, e), 
  t + 1;
 }
 writeUInt16BE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setUint16(t, e), 
  t + 2;
 }
 writeUInt16LE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setUint16(t, e, !0), 
  t + 2;
 }
 writeUInt32BE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setUint32(t, e), 
  t + 4;
 }
 writeUInt32LE(e, t = 0) {
  return new DataView(this.buffer, this.byteOffset, this.byteLength).setUint32(t, e, !0), 
  t + 4;
 }
}

Object.defineProperty(globalThis, "Buffer", {
 value: Buffer,
 enumerable: !1,
 writable: !0,
 configurable: !0
});

const nodeBuffer = {
 __proto__: null,
 default: Buffer,
 Buffer
};

class DenoStdInternalError extends Error {
 constructor(e) {
  super(e), this.name = "DenoStdInternalError";
 }
}

class EventEmitter {
 constructor() {
  this._events = new Map;
 }
 _addListener(e, t, n) {
  if (this.emit("newListener", e, t), this._events.has(e)) {
   const r = this._events.get(e);
   n ? r.unshift(t) : r.push(t);
  } else this._events.set(e, [ t ]);
  const r = this.getMaxListeners();
  if (r > 0 && this.listenerCount(e) > r) {
   const t = new Error(`Possible EventEmitter memory leak detected.\n         ${this.listenerCount(e)} ${e.toString()} listeners.\n         Use emitter.setMaxListeners() to increase limit`);
   t.name = "MaxListenersExceededWarning", console.warn(t);
  }
  return this;
 }
 addListener(e, t) {
  return this._addListener(e, t, !1);
 }
 emit(e, ...t) {
  if (this._events.has(e)) {
   "error" === e && this._events.get(EventEmitter.errorMonitor) && this.emit(EventEmitter.errorMonitor, ...t);
   const n = this._events.get(e).slice();
   for (const e of n) try {
    e.apply(this, t);
   } catch (e) {
    this.emit("error", e);
   }
   return !0;
  }
  if ("error" === e) throw this._events.get(EventEmitter.errorMonitor) && this.emit(EventEmitter.errorMonitor, ...t), 
  t.length > 0 ? t[0] : Error("Unhandled error.");
  return !1;
 }
 eventNames() {
  return Array.from(this._events.keys());
 }
 getMaxListeners() {
  return this.maxListeners || EventEmitter.defaultMaxListeners;
 }
 listenerCount(e) {
  return this._events.has(e) ? this._events.get(e).length : 0;
 }
 _listeners(e, t, n) {
  if (!e._events.has(t)) return [];
  const r = e._events.get(t);
  return n ? this.unwrapListeners(r) : r.slice(0);
 }
 unwrapListeners(e) {
  const t = new Array(e.length);
  for (let n = 0; n < e.length; n++) t[n] = e[n].listener || e[n];
  return t;
 }
 listeners(e) {
  return this._listeners(this, e, !0);
 }
 rawListeners(e) {
  return this._listeners(this, e, !1);
 }
 off(e, t) {
  return this.removeListener(e, t);
 }
 on(e, t) {
  return this.addListener(e, t);
 }
 once(e, t) {
  const n = this.onceWrap(e, t);
  return this.on(e, n), this;
 }
 onceWrap(e, t) {
  const n = function(...e) {
   this.context.removeListener(this.eventName, this.rawListener), this.listener.apply(this.context, e);
  }, r = {
   eventName: e,
   listener: t,
   rawListener: n,
   context: this
  }, o = n.bind(r);
  return r.rawListener = o, o.listener = t, o;
 }
 prependListener(e, t) {
  return this._addListener(e, t, !0);
 }
 prependOnceListener(e, t) {
  const n = this.onceWrap(e, t);
  return this.prependListener(e, n), this;
 }
 removeAllListeners(e) {
  if (void 0 === this._events) return this;
  if (e) {
   if (this._events.has(e)) {
    const t = this._events.get(e).slice();
    this._events.delete(e);
    for (const n of t) this.emit("removeListener", e, n);
   }
  } else this.eventNames().map(e => {
   this.removeAllListeners(e);
  });
  return this;
 }
 removeListener(e, t) {
  if (this._events.has(e)) {
   const n = this._events.get(e);
   assert(n);
   let r = -1;
   for (let e = n.length - 1; e >= 0; e--) if (n[e] == t || n[e] && n[e].listener == t) {
    r = e;
    break;
   }
   r >= 0 && (n.splice(r, 1), this.emit("removeListener", e, t), 0 === n.length && this._events.delete(e));
  }
  return this;
 }
 setMaxListeners(e) {
  return e !== 1 / 0 && (0 === e ? e = 1 / 0 : validateIntegerRange(e, "maxListeners", 0)), 
  this.maxListeners = e, this;
 }
}

EventEmitter.defaultMaxListeners = 10, EventEmitter.errorMonitor = Symbol("events.errorMonitor");

const captureRejectionSymbol = Symbol.for("nodejs.rejection"), nodeEvents = {
 __proto__: null,
 default: EventEmitter,
 EventEmitter,
 once: function once(e, t) {
  return new Promise((n, r) => {
   if (e instanceof EventTarget) e.addEventListener(t, (...e) => {
    n(e);
   }, {
    once: !0,
    passive: !1,
    capture: !1
   }); else if (e instanceof EventEmitter) {
    const o = (...t) => {
     void 0 !== i && e.removeListener("error", i), n(t);
    };
    let i;
    return "error" !== t && (i = n => {
     e.removeListener(t, o), r(n);
    }, e.once("error", i)), void e.once(t, o);
   }
  });
 },
 on: function on(e, t) {
  function n(...e) {
   const t = i.shift();
   t ? t.resolve(createIterResult(e, !1)) : o.push(e);
  }
  function r(e) {
   a = !0;
   const t = i.shift();
   t ? t.reject(e) : s = e, l.return();
  }
  const o = [], i = [];
  let s = null, a = !1;
  const l = {
   next() {
    const e = o.shift();
    if (e) return Promise.resolve(createIterResult(e, !1));
    if (s) {
     const e = Promise.reject(s);
     return s = null, e;
    }
    return a ? Promise.resolve(createIterResult(void 0, !0)) : new Promise((function(e, t) {
     i.push({
      resolve: e,
      reject: t
     });
    }));
   },
   return() {
    e.removeListener(t, n), e.removeListener("error", r), a = !0;
    for (const e of i) e.resolve(createIterResult(void 0, !0));
    return Promise.resolve(createIterResult(void 0, !0));
   },
   throw(o) {
    s = o, e.removeListener(t, n), e.removeListener("error", r);
   },
   [Symbol.asyncIterator]() {
    return this;
   }
  };
  return e.on(t, n), e.on("error", r), l;
 },
 captureRejectionSymbol
};

let NATIVE_OS = "linux";

const navigator = globalThis.navigator;

null != globalThis.Deno ? NATIVE_OS = Deno.build.os : null !== (_c = null === (_b = null === (_a = null == navigator ? void 0 : navigator.appVersion) || void 0 === _a ? void 0 : _a.includes) || void 0 === _b ? void 0 : _b.call(_a, "Win")) && void 0 !== _c && _c && (NATIVE_OS = "windows");

const isWindows = "windows" == NATIVE_OS, _win32 = {
 __proto__: null,
 sep: "\\",
 delimiter: ";",
 resolve,
 normalize,
 isAbsolute: function isAbsolute(e) {
  assertPath(e);
  const t = e.length;
  if (0 === t) return !1;
  const n = e.charCodeAt(0);
  return !!isPathSeparator(n) || !!(isWindowsDeviceRoot(n) && t > 2 && 58 === e.charCodeAt(1) && isPathSeparator(e.charCodeAt(2)));
 },
 join: function join(...e) {
  const t = e.length;
  if (0 === t) return ".";
  let n, r = null;
  for (let o = 0; o < t; ++o) {
   const t = e[o];
   assertPath(t), t.length > 0 && (void 0 === n ? n = r = t : n += "\\" + t);
  }
  if (void 0 === n) return ".";
  let o = !0, i = 0;
  if (assert(null != r), isPathSeparator(r.charCodeAt(0))) {
   ++i;
   const e = r.length;
   e > 1 && isPathSeparator(r.charCodeAt(1)) && (++i, e > 2 && (isPathSeparator(r.charCodeAt(2)) ? ++i : o = !1));
  }
  if (o) {
   for (;i < n.length && isPathSeparator(n.charCodeAt(i)); ++i) ;
   i >= 2 && (n = "\\" + n.slice(i));
  }
  return normalize(n);
 },
 relative: function relative(e, t) {
  if (assertPath(e), assertPath(t), e === t) return "";
  const n = resolve(e), r = resolve(t);
  if (n === r) return "";
  if ((e = n.toLowerCase()) === (t = r.toLowerCase())) return "";
  let o = 0, i = e.length;
  for (;o < i && 92 === e.charCodeAt(o); ++o) ;
  for (;i - 1 > o && 92 === e.charCodeAt(i - 1); --i) ;
  const s = i - o;
  let a = 0, l = t.length;
  for (;a < l && 92 === t.charCodeAt(a); ++a) ;
  for (;l - 1 > a && 92 === t.charCodeAt(l - 1); --l) ;
  const c = l - a, u = s < c ? s : c;
  let f = -1, d = 0;
  for (;d <= u; ++d) {
   if (d === u) {
    if (c > u) {
     if (92 === t.charCodeAt(a + d)) return r.slice(a + d + 1);
     if (2 === d) return r.slice(a + d);
    }
    s > u && (92 === e.charCodeAt(o + d) ? f = d : 2 === d && (f = 3));
    break;
   }
   const n = e.charCodeAt(o + d);
   if (n !== t.charCodeAt(a + d)) break;
   92 === n && (f = d);
  }
  if (d !== u && -1 === f) return r;
  let h = "";
  for (-1 === f && (f = 0), d = o + f + 1; d <= i; ++d) d !== i && 92 !== e.charCodeAt(d) || (0 === h.length ? h += ".." : h += "\\..");
  return h.length > 0 ? h + r.slice(a + f, l) : (a += f, 92 === r.charCodeAt(a) && ++a, 
  r.slice(a, l));
 },
 toNamespacedPath: function toNamespacedPath(e) {
  if ("string" != typeof e) return e;
  if (0 === e.length) return "";
  const t = resolve(e);
  if (t.length >= 3) if (92 === t.charCodeAt(0)) {
   if (92 === t.charCodeAt(1)) {
    const e = t.charCodeAt(2);
    if (63 !== e && 46 !== e) return "\\\\?\\UNC\\" + t.slice(2);
   }
  } else if (isWindowsDeviceRoot(t.charCodeAt(0)) && 58 === t.charCodeAt(1) && 92 === t.charCodeAt(2)) return "\\\\?\\" + t;
  return e;
 },
 dirname: function dirname(e) {
  assertPath(e);
  const t = e.length;
  if (0 === t) return ".";
  let n = -1, r = -1, o = !0, i = 0;
  const s = e.charCodeAt(0);
  if (t > 1) if (isPathSeparator(s)) {
   if (n = i = 1, isPathSeparator(e.charCodeAt(1))) {
    let r = 2, o = r;
    for (;r < t && !isPathSeparator(e.charCodeAt(r)); ++r) ;
    if (r < t && r !== o) {
     for (o = r; r < t && isPathSeparator(e.charCodeAt(r)); ++r) ;
     if (r < t && r !== o) {
      for (o = r; r < t && !isPathSeparator(e.charCodeAt(r)); ++r) ;
      if (r === t) return e;
      r !== o && (n = i = r + 1);
     }
    }
   }
  } else isWindowsDeviceRoot(s) && 58 === e.charCodeAt(1) && (n = i = 2, t > 2 && isPathSeparator(e.charCodeAt(2)) && (n = i = 3)); else if (isPathSeparator(s)) return e;
  for (let n = t - 1; n >= i; --n) if (isPathSeparator(e.charCodeAt(n))) {
   if (!o) {
    r = n;
    break;
   }
  } else o = !1;
  if (-1 === r) {
   if (-1 === n) return ".";
   r = n;
  }
  return e.slice(0, r);
 },
 basename: function basename(e, t = "") {
  if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string');
  assertPath(e);
  let n, r = 0, o = -1, i = !0;
  if (e.length >= 2 && isWindowsDeviceRoot(e.charCodeAt(0)) && 58 === e.charCodeAt(1) && (r = 2), 
  void 0 !== t && t.length > 0 && t.length <= e.length) {
   if (t.length === e.length && t === e) return "";
   let s = t.length - 1, a = -1;
   for (n = e.length - 1; n >= r; --n) {
    const l = e.charCodeAt(n);
    if (isPathSeparator(l)) {
     if (!i) {
      r = n + 1;
      break;
     }
    } else -1 === a && (i = !1, a = n + 1), s >= 0 && (l === t.charCodeAt(s) ? -1 == --s && (o = n) : (s = -1, 
    o = a));
   }
   return r === o ? o = a : -1 === o && (o = e.length), e.slice(r, o);
  }
  for (n = e.length - 1; n >= r; --n) if (isPathSeparator(e.charCodeAt(n))) {
   if (!i) {
    r = n + 1;
    break;
   }
  } else -1 === o && (i = !1, o = n + 1);
  return -1 === o ? "" : e.slice(r, o);
 },
 extname: function extname(e) {
  assertPath(e);
  let t = 0, n = -1, r = 0, o = -1, i = !0, s = 0;
  e.length >= 2 && 58 === e.charCodeAt(1) && isWindowsDeviceRoot(e.charCodeAt(0)) && (t = r = 2);
  for (let a = e.length - 1; a >= t; --a) {
   const t = e.charCodeAt(a);
   if (isPathSeparator(t)) {
    if (!i) {
     r = a + 1;
     break;
    }
   } else -1 === o && (i = !1, o = a + 1), 46 === t ? -1 === n ? n = a : 1 !== s && (s = 1) : -1 !== n && (s = -1);
  }
  return -1 === n || -1 === o || 0 === s || 1 === s && n === o - 1 && n === r + 1 ? "" : e.slice(n, o);
 },
 format: function format(e) {
  if (null === e || "object" != typeof e) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
  return _format("\\", e);
 },
 parse: function parse(e) {
  assertPath(e);
  const t = {
   root: "",
   dir: "",
   base: "",
   ext: "",
   name: ""
  }, n = e.length;
  if (0 === n) return t;
  let r = 0, o = e.charCodeAt(0);
  if (n > 1) {
   if (isPathSeparator(o)) {
    if (r = 1, isPathSeparator(e.charCodeAt(1))) {
     let t = 2, o = t;
     for (;t < n && !isPathSeparator(e.charCodeAt(t)); ++t) ;
     if (t < n && t !== o) {
      for (o = t; t < n && isPathSeparator(e.charCodeAt(t)); ++t) ;
      if (t < n && t !== o) {
       for (o = t; t < n && !isPathSeparator(e.charCodeAt(t)); ++t) ;
       t === n ? r = t : t !== o && (r = t + 1);
      }
     }
    }
   } else if (isWindowsDeviceRoot(o) && 58 === e.charCodeAt(1)) {
    if (r = 2, !(n > 2)) return t.root = t.dir = e, t;
    if (isPathSeparator(e.charCodeAt(2))) {
     if (3 === n) return t.root = t.dir = e, t;
     r = 3;
    }
   }
  } else if (isPathSeparator(o)) return t.root = t.dir = e, t;
  r > 0 && (t.root = e.slice(0, r));
  let i = -1, s = r, a = -1, l = !0, c = e.length - 1, u = 0;
  for (;c >= r; --c) if (o = e.charCodeAt(c), isPathSeparator(o)) {
   if (!l) {
    s = c + 1;
    break;
   }
  } else -1 === a && (l = !1, a = c + 1), 46 === o ? -1 === i ? i = c : 1 !== u && (u = 1) : -1 !== i && (u = -1);
  return -1 === i || -1 === a || 0 === u || 1 === u && i === a - 1 && i === s + 1 ? -1 !== a && (t.base = t.name = e.slice(s, a)) : (t.name = e.slice(s, i), 
  t.base = e.slice(s, a), t.ext = e.slice(i, a)), t.dir = s > 0 && s !== r ? e.slice(0, s - 1) : t.root, 
  t;
 },
 fromFileUrl: function fromFileUrl(e) {
  if ("file:" != (e = e instanceof URL ? e : new URL(e)).protocol) throw new TypeError("Must be a file URL.");
  let t = decodeURIComponent(e.pathname.replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/").replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
  return "" != e.hostname && (t = `\\\\${e.hostname}${t}`), t;
 }
}, _posix = {
 __proto__: null,
 sep: "/",
 delimiter: ":",
 resolve: resolve$1,
 normalize: normalize$1,
 isAbsolute: function isAbsolute$1(e) {
  return assertPath(e), e.length > 0 && 47 === e.charCodeAt(0);
 },
 join: function join$1(...e) {
  if (0 === e.length) return ".";
  let t;
  for (let n = 0, r = e.length; n < r; ++n) {
   const r = e[n];
   assertPath(r), r.length > 0 && (t ? t += "/" + r : t = r);
  }
  return t ? normalize$1(t) : ".";
 },
 relative: function relative$1(e, t) {
  if (assertPath(e), assertPath(t), e === t) return "";
  if ((e = resolve$1(e)) === (t = resolve$1(t))) return "";
  let n = 1;
  const r = e.length;
  for (;n < r && 47 === e.charCodeAt(n); ++n) ;
  const o = r - n;
  let i = 1;
  const s = t.length;
  for (;i < s && 47 === t.charCodeAt(i); ++i) ;
  const a = s - i, l = o < a ? o : a;
  let c = -1, u = 0;
  for (;u <= l; ++u) {
   if (u === l) {
    if (a > l) {
     if (47 === t.charCodeAt(i + u)) return t.slice(i + u + 1);
     if (0 === u) return t.slice(i + u);
    } else o > l && (47 === e.charCodeAt(n + u) ? c = u : 0 === u && (c = 0));
    break;
   }
   const r = e.charCodeAt(n + u);
   if (r !== t.charCodeAt(i + u)) break;
   47 === r && (c = u);
  }
  let f = "";
  for (u = n + c + 1; u <= r; ++u) u !== r && 47 !== e.charCodeAt(u) || (0 === f.length ? f += ".." : f += "/..");
  return f.length > 0 ? f + t.slice(i + c) : (i += c, 47 === t.charCodeAt(i) && ++i, 
  t.slice(i));
 },
 toNamespacedPath: function toNamespacedPath$1(e) {
  return e;
 },
 dirname: function dirname$1(e) {
  if (assertPath(e), 0 === e.length) return ".";
  const t = 47 === e.charCodeAt(0);
  let n = -1, r = !0;
  for (let t = e.length - 1; t >= 1; --t) if (47 === e.charCodeAt(t)) {
   if (!r) {
    n = t;
    break;
   }
  } else r = !1;
  return -1 === n ? t ? "/" : "." : t && 1 === n ? "//" : e.slice(0, n);
 },
 basename: function basename$1(e, t = "") {
  if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string');
  assertPath(e);
  let n, r = 0, o = -1, i = !0;
  if (void 0 !== t && t.length > 0 && t.length <= e.length) {
   if (t.length === e.length && t === e) return "";
   let s = t.length - 1, a = -1;
   for (n = e.length - 1; n >= 0; --n) {
    const l = e.charCodeAt(n);
    if (47 === l) {
     if (!i) {
      r = n + 1;
      break;
     }
    } else -1 === a && (i = !1, a = n + 1), s >= 0 && (l === t.charCodeAt(s) ? -1 == --s && (o = n) : (s = -1, 
    o = a));
   }
   return r === o ? o = a : -1 === o && (o = e.length), e.slice(r, o);
  }
  for (n = e.length - 1; n >= 0; --n) if (47 === e.charCodeAt(n)) {
   if (!i) {
    r = n + 1;
    break;
   }
  } else -1 === o && (i = !1, o = n + 1);
  return -1 === o ? "" : e.slice(r, o);
 },
 extname: function extname$1(e) {
  assertPath(e);
  let t = -1, n = 0, r = -1, o = !0, i = 0;
  for (let s = e.length - 1; s >= 0; --s) {
   const a = e.charCodeAt(s);
   if (47 !== a) -1 === r && (o = !1, r = s + 1), 46 === a ? -1 === t ? t = s : 1 !== i && (i = 1) : -1 !== t && (i = -1); else if (!o) {
    n = s + 1;
    break;
   }
  }
  return -1 === t || -1 === r || 0 === i || 1 === i && t === r - 1 && t === n + 1 ? "" : e.slice(t, r);
 },
 format: function format$1(e) {
  if (null === e || "object" != typeof e) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
  return _format("/", e);
 },
 parse: function parse$1(e) {
  assertPath(e);
  const t = {
   root: "",
   dir: "",
   base: "",
   ext: "",
   name: ""
  };
  if (0 === e.length) return t;
  const n = 47 === e.charCodeAt(0);
  let r;
  n ? (t.root = "/", r = 1) : r = 0;
  let o = -1, i = 0, s = -1, a = !0, l = e.length - 1, c = 0;
  for (;l >= r; --l) {
   const t = e.charCodeAt(l);
   if (47 !== t) -1 === s && (a = !1, s = l + 1), 46 === t ? -1 === o ? o = l : 1 !== c && (c = 1) : -1 !== o && (c = -1); else if (!a) {
    i = l + 1;
    break;
   }
  }
  return -1 === o || -1 === s || 0 === c || 1 === c && o === s - 1 && o === i + 1 ? -1 !== s && (t.base = t.name = 0 === i && n ? e.slice(1, s) : e.slice(i, s)) : (0 === i && n ? (t.name = e.slice(1, o), 
  t.base = e.slice(1, s)) : (t.name = e.slice(i, o), t.base = e.slice(i, s)), t.ext = e.slice(o, s)), 
  i > 0 ? t.dir = e.slice(0, i - 1) : n && (t.dir = "/"), t;
 },
 fromFileUrl: function fromFileUrl$1(e) {
  if ("file:" != (e = e instanceof URL ? e : new URL(e)).protocol) throw new TypeError("Must be a file URL.");
  return decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
 }
}, SEP = isWindows ? "\\" : "/", SEP_PATTERN = isWindows ? /[\\/]+/ : /\/+/, regExpEscapeChars = [ "!", "$", "(", ")", "*", "+", ".", "=", "?", "[", "\\", "^", "{", "|" ], rangeEscapeChars = [ "-", "\\", "]" ], path = isWindows ? _win32 : _posix, win32 = _win32, posix = _posix, {basename: basename$2, delimiter: delimiter$2, dirname: dirname$2, extname: extname$2, format: format$2, fromFileUrl: fromFileUrl$2, isAbsolute: isAbsolute$2, join: join$2, normalize: normalize$2, parse: parse$2, relative: relative$2, resolve: resolve$2, sep: sep$2, toNamespacedPath: toNamespacedPath$2} = path, nodePath = {
 __proto__: null,
 SEP,
 SEP_PATTERN,
 common: function common(e, t = SEP) {
  const [n = "", ...r] = e;
  if ("" === n || 0 === r.length) return n.substring(0, n.lastIndexOf(t) + 1);
  const o = n.split(t);
  let i = o.length;
  for (const e of r) {
   const n = e.split(t);
   for (let e = 0; e < i; e++) n[e] !== o[e] && (i = e);
   if (0 === i) return "";
  }
  const s = o.slice(0, i).join(t);
  return s.endsWith(t) ? s : `${s}${t}`;
 },
 globToRegExp: function globToRegExp(e, {extended: t = !0, globstar: n = !0, os: r = NATIVE_OS} = {}) {
  if ("" == e) return /(?!)/;
  const o = "windows" == r ? "(?:\\\\|/)+" : "/+", i = "windows" == r ? "(?:\\\\|/)*" : "/*", s = "windows" == r ? [ "\\", "/" ] : [ "/" ], a = "windows" == r ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*", l = "windows" == r ? "[^\\\\/]*" : "[^/]*", c = "windows" == r ? "`" : "\\";
  let u = e.length;
  for (;u > 1 && s.includes(e[u - 1]); u--) ;
  e = e.slice(0, u);
  let f = "";
  for (let r = 0; r < e.length; ) {
   let u = "";
   const d = [];
   let h = !1, p = !1, m = !1, g = r;
   for (;g < e.length && !s.includes(e[g]); g++) if (p) p = !1, u += (h ? rangeEscapeChars : regExpEscapeChars).includes(e[g]) ? "\\" + e[g] : e[g]; else if (e[g] != c) {
    if ("[" == e[g]) {
     if (!h) {
      h = !0, u += "[", "!" == e[g + 1] ? (g++, u += "^") : "^" == e[g + 1] && (g++, u += "\\^");
      continue;
     }
     if (":" == e[g + 1]) {
      let t = g + 1, n = "";
      for (;null != e[t + 1] && ":" != e[t + 1]; ) n += e[t + 1], t++;
      if (":" == e[t + 1] && "]" == e[t + 2]) {
       g = t + 2, "alnum" == n ? u += "\\dA-Za-z" : "alpha" == n ? u += "A-Za-z" : "ascii" == n ? u += "\0-" : "blank" == n ? u += "\t " : "cntrl" == n ? u += "\0-" : "digit" == n ? u += "\\d" : "graph" == n ? u += "!-~" : "lower" == n ? u += "a-z" : "print" == n ? u += " -~" : "punct" == n ? u += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~" : "space" == n ? u += "\\s\v" : "upper" == n ? u += "A-Z" : "word" == n ? u += "\\w" : "xdigit" == n && (u += "\\dA-Fa-f");
       continue;
      }
     }
    }
    if ("]" == e[g] && h) h = !1, u += "]"; else if (h) "\\" == e[g] ? u += "\\\\" : u += e[g]; else if (")" == e[g] && d.length > 0 && "BRACE" != d[d.length - 1]) {
     u += ")";
     const e = d.pop();
     "!" == e ? u += l : "@" != e && (u += e);
    } else if ("|" == e[g] && d.length > 0 && "BRACE" != d[d.length - 1]) u += "|"; else if ("+" == e[g] && t && "(" == e[g + 1]) g++, 
    d.push("+"), u += "(?:"; else if ("@" == e[g] && t && "(" == e[g + 1]) g++, d.push("@"), 
    u += "(?:"; else if ("?" != e[g]) if ("!" == e[g] && t && "(" == e[g + 1]) g++, 
    d.push("!"), u += "(?!"; else if ("{" != e[g]) if ("}" != e[g] || "BRACE" != d[d.length - 1]) if ("," != e[g] || "BRACE" != d[d.length - 1]) if ("*" != e[g]) u += regExpEscapeChars.includes(e[g]) ? "\\" + e[g] : e[g]; else if (t && "(" == e[g + 1]) g++, 
    d.push("*"), u += "(?:"; else {
     const t = e[g - 1];
     let r = 1;
     for (;"*" == e[g + 1]; ) g++, r++;
     const o = e[g + 1];
     n && 2 == r && [ ...s, void 0 ].includes(t) && [ ...s, void 0 ].includes(o) ? (u += a, 
     m = !0) : u += l;
    } else u += "|"; else d.pop(), u += ")"; else d.push("BRACE"), u += "(?:"; else t && "(" == e[g + 1] ? (g++, 
    d.push("?"), u += "(?:") : u += ".";
   } else p = !0;
   if (d.length > 0 || h || p) {
    u = "";
    for (const t of e.slice(r, g)) u += regExpEscapeChars.includes(t) ? "\\" + t : t, 
    m = !1;
   }
   for (f += u, m || (f += g < e.length ? o : i, m = !0); s.includes(e[g]); ) g++;
   if (!(g > r)) throw new Error("Assertion failure: i > j (potential infinite loop)");
   r = g;
  }
  return f = `^${f}$`, new RegExp(f);
 },
 isGlob: function isGlob(e) {
  const t = {
   "{": "}",
   "(": ")",
   "[": "]"
  }, n = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  if ("" === e) return !1;
  let r;
  for (;r = n.exec(e); ) {
   if (r[2]) return !0;
   let n = r.index + r[0].length;
   const o = r[1], i = o ? t[o] : null;
   if (o && i) {
    const t = e.indexOf(i, n);
    -1 !== t && (n = t + 1);
   }
   e = e.slice(n);
  }
  return !1;
 },
 normalizeGlob,
 joinGlobs: function joinGlobs(e, {extended: t = !1, globstar: n = !1} = {}) {
  if (!n || 0 == e.length) return join$2(...e);
  if (0 === e.length) return ".";
  let r;
  for (const t of e) {
   const e = t;
   e.length > 0 && (r ? r += `${SEP}${e}` : r = e);
  }
  return r ? normalizeGlob(r, {
   extended: t,
   globstar: n
  }) : ".";
 },
 win32,
 posix,
 basename: basename$2,
 delimiter: delimiter$2,
 dirname: dirname$2,
 extname: extname$2,
 format: format$2,
 fromFileUrl: fromFileUrl$2,
 isAbsolute: isAbsolute$2,
 join: join$2,
 normalize: normalize$2,
 parse: parse$2,
 relative: relative$2,
 resolve: resolve$2,
 sep: sep$2,
 toNamespacedPath: toNamespacedPath$2
}, allowedModes = /^[0-7]{3}/;

class FSWatcher extends EventEmitter {
 constructor(e) {
  super(), this.close = e;
 }
 ref() {
  notImplemented("FSWatcher.ref() is not implemented");
 }
 unref() {
  notImplemented("FSWatcher.unref() is not implemented");
 }
}

class Dirent {
 constructor(e) {
  this.entry = e;
 }
 isBlockDevice() {
  return notImplemented("Deno does not yet support identification of block devices"), 
  !1;
 }
 isCharacterDevice() {
  return notImplemented("Deno does not yet support identification of character devices"), 
  !1;
 }
 isDirectory() {
  return this.entry.isDirectory;
 }
 isFIFO() {
  return notImplemented("Deno does not yet support identification of FIFO named pipes"), 
  !1;
 }
 isFile() {
  return this.entry.isFile;
 }
 isSocket() {
  return notImplemented("Deno does not yet support identification of sockets"), !1;
 }
 isSymbolicLink() {
  return this.entry.isSymlink;
 }
 get name() {
  return this.entry.name;
 }
}

!function(e) {
 e.LF = "\n", e.CRLF = "\r\n";
}(EOL || (EOL = {}));

const nodeFs = {
 __proto__: null,
 access: function access(e, t, n) {
  notImplemented("Not yet available");
 },
 accessSync: function accessSync(e, t) {
  notImplemented("Not yet available");
 },
 appendFile: function appendFile(e, t, n, r) {
  e = e instanceof URL ? fromFileUrl$2(e) : e;
  const o = n instanceof Function ? n : r, i = n instanceof Function ? void 0 : n;
  if (!o) throw new Error("No callback function supplied");
  validateEncoding(i);
  let s = -1;
  const a = t instanceof Uint8Array ? t : (new TextEncoder).encode(t);
  new Promise((t, n) => {
   if ("number" == typeof e) s = e, Deno.write(s, a).then(t).catch(n); else {
    const r = isFileOptions(i) ? i.mode : void 0, o = isFileOptions(i) ? i.flag : void 0;
    r && notImplemented("Deno does not yet support setting mode on create"), Deno.open(e, getOpenOptions(o)).then(({rid: e}) => (s = e, 
    Deno.write(e, a))).then(t).catch(n);
   }
  }).then(() => {
   closeRidIfNecessary("string" == typeof e, s), o();
  }).catch(t => {
   closeRidIfNecessary("string" == typeof e, s), o(t);
  });
 },
 appendFileSync: function appendFileSync(e, t, n) {
  let r = -1;
  validateEncoding(n), e = e instanceof URL ? fromFileUrl$2(e) : e;
  try {
   if ("number" == typeof e) r = e; else {
    const t = isFileOptions(n) ? n.mode : void 0, o = isFileOptions(n) ? n.flag : void 0;
    t && notImplemented("Deno does not yet support setting mode on create"), r = Deno.openSync(e, getOpenOptions(o)).rid;
   }
   const o = t instanceof Uint8Array ? t : (new TextEncoder).encode(t);
   Deno.writeSync(r, o);
  } finally {
   closeRidIfNecessary("string" == typeof e, r);
  }
 },
 chmod: function chmod(e, t, n) {
  e = e instanceof URL ? fromFileUrl$2(e) : e, Deno.chmod(e, getResolvedMode(t)).then(() => n()).catch(n);
 },
 chmodSync: function chmodSync(e, t) {
  e = e instanceof URL ? fromFileUrl$2(e) : e, Deno.chmodSync(e, getResolvedMode(t));
 },
 chown: function chown(e, t, n, r) {
  e = e instanceof URL ? fromFileUrl$2(e) : e, Deno.chown(e, t, n).then(() => r()).catch(r);
 },
 chownSync: function chownSync(e, t, n) {
  e = e instanceof URL ? fromFileUrl$2(e) : e, Deno.chownSync(e, t, n);
 },
 close: function close(e, t) {
  queueMicrotask(() => {
   try {
    Deno.close(e), t(null);
   } catch (e) {
    t(e);
   }
  });
 },
 closeSync: function closeSync(e) {
  Deno.close(e);
 },
 constants: {
  __proto__: null,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1
 },
 copyFile: function copyFile(e, t, n) {
  e = e instanceof URL ? fromFileUrl$2(e) : e, Deno.copyFile(e, t).then(() => n()).catch(n);
 },
 copyFileSync: function copyFileSync(e, t) {
  e = e instanceof URL ? fromFileUrl$2(e) : e, Deno.copyFileSync(e, t);
 },
 exists: function exists(e, t) {
  e = e instanceof URL ? fromFileUrl$2(e) : e, Deno.lstat(e).then(() => {
   t(!0);
  }).catch(() => t(!1));
 },
 existsSync: function existsSync(e) {
  e = e instanceof URL ? fromFileUrl$2(e) : e;
  try {
   return Deno.lstatSync(e), !0;
  } catch (e) {
   if (e instanceof Deno.errors.NotFound) return !1;
   throw e;
  }
 },
 lstat: function lstat(e, t, n) {
  const r = "function" == typeof t ? t : n, o = "object" == typeof t ? t : {
   bigint: !1
  };
  if (!r) throw new Error("No callback function supplied");
  Deno.lstat(e).then(e => r(void 0, CFISBIS(e, o.bigint))).catch(e => r(e, e));
 },
 lstatSync: function lstatSync(e, t) {
  return CFISBIS(Deno.lstatSync(e), (null == t ? void 0 : t.bigint) || !1);
 },
 mkdir: function mkdir(e, t, n) {
  e = e instanceof URL ? fromFileUrl$2(e) : e;
  let r = 511, o = !1;
  if ("function" == typeof t ? n = t : "number" == typeof t ? r = t : "boolean" == typeof t ? o = t : t && (void 0 !== t.recursive && (o = t.recursive), 
  void 0 !== t.mode && (r = t.mode)), "boolean" != typeof o) throw new Deno.errors.InvalidData("invalid recursive option , must be a boolean");
  Deno.mkdir(e, {
   recursive: o,
   mode: r
  }).then(() => {
   "function" == typeof n && n();
  }).catch(e => {
   "function" == typeof n && n(e);
  });
 },
 mkdirSync: function mkdirSync(e, t) {
  e = e instanceof URL ? fromFileUrl$2(e) : e;
  let n = 511, r = !1;
  if ("number" == typeof t ? n = t : "boolean" == typeof t ? r = t : t && (void 0 !== t.recursive && (r = t.recursive), 
  void 0 !== t.mode && (n = t.mode)), "boolean" != typeof r) throw new Deno.errors.InvalidData("invalid recursive option , must be a boolean");
  Deno.mkdirSync(e, {
   recursive: r,
   mode: n
  });
 },
 open: function open(e, t, n, r) {
  const o = "string" == typeof t ? t : void 0, i = "function" == typeof t ? t : "function" == typeof n ? n : r, s = "number" == typeof n ? n : void 0;
  if (e = e instanceof URL ? fromFileUrl$2(e) : e, !i) throw new Error("No callback function supplied");
  if ([ "ax", "ax+", "wx", "wx+" ].includes(o || "") && existsSync$1(e)) {
   const t = new Error(`EEXIST: file already exists, open '${e}'`);
   i(t, 0);
  } else {
   if ("as" === o || "as+" === o) {
    try {
     const t = openSync(e, o, s);
     i(void 0, t);
    } catch (e) {
     i(e, e);
    }
    return;
   }
   Deno.open(e, convertFlagAndModeToOptions(o, s)).then(e => i(void 0, e.rid)).catch(e => i(e, e));
  }
 },
 openSync,
 promises: {
  __proto__: null,
  writeFile: function writeFile$1(e, t, n) {
   return new Promise((r, o) => {
    writeFile(e, t, n, e => {
     if (e) return o(e);
     r();
    });
   });
  },
  readFile: function readFile$1(e, t) {
   return new Promise((n, r) => {
    readFile(e, t, (e, t) => e ? r(e) : null == t ? r(new Error("Invalid state: data missing, but no error")) : void n(t));
   });
  }
 },
 readdir: function readdir(e, t, n) {
  const r = "function" == typeof t ? t : n, o = "object" == typeof t ? t : null, i = [];
  if (e = e instanceof URL ? fromFileUrl$2(e) : e, !r) throw new Error("No callback function supplied");
  if (null == o ? void 0 : o.encoding) try {
   new TextDecoder(o.encoding);
  } catch (e) {
   throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${o.encoding}" is invalid for option "encoding"`);
  }
  try {
   !function s(e, t) {
    const n = e[Symbol.asyncIterator]();
    !function e() {
     n.next().then(n => {
      n.done ? t(n.value, !0) : (t(n.value), e());
     });
    }();
   }(Deno.readDir(e), (t, n) => {
    "string" == typeof e && (n ? r(void 0, i) : (null == o ? void 0 : o.withFileTypes) ? i.push(toDirent(t)) : i.push(decode$2(t.name)));
   });
  } catch (e) {
   r(e, i);
  }
 },
 readdirSync: function readdirSync(e, t) {
  const n = [];
  if (e = e instanceof URL ? fromFileUrl$2(e) : e, null == t ? void 0 : t.encoding) try {
   new TextDecoder(t.encoding);
  } catch (e) {
   throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${t.encoding}" is invalid for option "encoding"`);
  }
  for (const r of Deno.readDirSync(e)) (null == t ? void 0 : t.withFileTypes) ? n.push(toDirent(r)) : n.push(decode$2(r.name));
  return n;
 },
 readFile,
 readFileSync: function readFileSync(e, t) {
  e = e instanceof URL ? fromFileUrl$2(e) : e;
  const n = Deno.readFileSync(e), r = getEncoding(t);
  return maybeDecode(n, r);
 },
 readlink: function readlink(e, t, n) {
  let r;
  e = e instanceof URL ? fromFileUrl$2(e) : e, r = "function" == typeof t ? t : n;
  const o = getEncoding$1(t);
  !function i(e, t, n, ...r) {
   e(...r).then(e => n && n(null, t(e))).catch(e => n && n(e, null));
  }(Deno.readLink, e => maybeEncode(e, o), r, e);
 },
 readlinkSync: function readlinkSync(e, t) {
  return e = e instanceof URL ? fromFileUrl$2(e) : e, maybeEncode(Deno.readLinkSync(e), getEncoding$1(t));
 },
 rename: function rename(e, t, n) {
  if (e = e instanceof URL ? fromFileUrl$2(e) : e, t = t instanceof URL ? fromFileUrl$2(t) : t, 
  !n) throw new Error("No callback function supplied");
  Deno.rename(e, t).then(e => n()).catch(n);
 },
 renameSync: function renameSync(e, t) {
  e = e instanceof URL ? fromFileUrl$2(e) : e, t = t instanceof URL ? fromFileUrl$2(t) : t, 
  Deno.renameSync(e, t);
 },
 rmdir: function rmdir(e, t, n) {
  const r = "function" == typeof t ? t : n, o = "object" == typeof t ? t : void 0;
  if (!r) throw new Error("No callback function supplied");
  Deno.remove(e, {
   recursive: null == o ? void 0 : o.recursive
  }).then(e => r()).catch(r);
 },
 rmdirSync: function rmdirSync(e, t) {
  Deno.removeSync(e, {
   recursive: null == t ? void 0 : t.recursive
  });
 },
 stat: function stat(e, t, n) {
  const r = "function" == typeof t ? t : n, o = "object" == typeof t ? t : {
   bigint: !1
  };
  if (!r) throw new Error("No callback function supplied");
  Deno.stat(e).then(e => r(void 0, CFISBIS(e, o.bigint))).catch(e => r(e, e));
 },
 statSync: function statSync(e, t = {
  bigint: !1
 }) {
  return CFISBIS(Deno.statSync(e), t.bigint);
 },
 unlink: function unlink(e, t) {
  if (!t) throw new Error("No callback function supplied");
  Deno.remove(e).then(e => t()).catch(t);
 },
 unlinkSync: function unlinkSync(e) {
  Deno.removeSync(e);
 },
 watch: function watch(e, t, n) {
  const r = "function" == typeof t ? t : "function" == typeof n ? n : void 0, o = "object" == typeof t ? t : "object" == typeof n ? n : void 0;
  e = e instanceof URL ? fromFileUrl$2(e) : e;
  const i = Deno.watchFs(e, {
   recursive: (null == o ? void 0 : o.recursive) || !1
  });
  if (!r) throw new Error("No callback function supplied");
  const s = new FSWatcher(() => {
   i.return && i.return();
  });
  return s.on("change", r), function a(e, t) {
   !function n() {
    e.next().then(e => {
     e.done ? t(e.value, !0) : (t(e.value), n());
    });
   }();
  }(i, (e, t) => {
   t || s.emit("change", e.kind, e.paths[0]);
  }), s;
 },
 writeFile,
 writeFileSync: function writeFileSync(e, t, n) {
  e = e instanceof URL ? fromFileUrl$2(e) : e;
  const r = isFileOptions(n) ? n.flag : void 0, o = isFileOptions(n) ? n.mode : void 0, i = checkEncoding$1(getEncoding(n)) || "utf8", s = getOpenOptions(r || "w");
  "string" == typeof t && (t = Buffer.from(t, i));
  const a = "number" == typeof e;
  let l, c = null;
  try {
   l = a ? new Deno.File(e) : Deno.openSync(e, s), !a && o && ("windows" === Deno.build.os && notImplemented('"mode" on Windows'), 
   Deno.chmodSync(e, o)), Deno.writeAllSync(l, t);
  } catch (e) {
   c = e;
  } finally {
   if (!a && l && l.close(), c) throw c;
  }
 }
}, process = {
 arch: Deno.build.arch,
 chdir: Deno.chdir,
 cwd: Deno.cwd,
 exit: Deno.exit,
 pid: Deno.pid,
 platform: "windows" === Deno.build.os ? "win32" : Deno.build.os,
 version: "v12.0.0",
 versions: Object.assign({
  node: "v12.0.0"
 }, Deno.version),
 on() {},
 env: {},
 argv: [ "deno", ...Deno.args ]
}, SEE_GITHUB_ISSUE = "See https://github.com/denoland/deno/issues/3802";

arch$1[Symbol.toPrimitive] = () => arch$1(), endianness[Symbol.toPrimitive] = () => endianness(), 
freemem[Symbol.toPrimitive] = () => freemem(), homedir[Symbol.toPrimitive] = () => homedir(), 
hostname[Symbol.toPrimitive] = () => hostname(), platform$1[Symbol.toPrimitive] = () => platform$1(), 
release[Symbol.toPrimitive] = () => release(), totalmem[Symbol.toPrimitive] = () => totalmem(), 
type[Symbol.toPrimitive] = () => type(), uptime[Symbol.toPrimitive] = () => uptime();

const nodeOs = {
 __proto__: null,
 arch: arch$1,
 cpus: function cpus() {
  notImplemented(SEE_GITHUB_ISSUE);
 },
 endianness,
 freemem,
 getPriority: function getPriority(e = 0) {
  validateIntegerRange(e, "pid"), notImplemented(SEE_GITHUB_ISSUE);
 },
 homedir,
 hostname,
 loadavg: function loadavg() {
  return "windows" === Deno.build.os ? [ 0, 0, 0 ] : Deno.loadavg();
 },
 networkInterfaces: function networkInterfaces() {
  notImplemented(SEE_GITHUB_ISSUE);
 },
 platform: platform$1,
 release,
 setPriority: function setPriority(e, t) {
  void 0 === t && (t = e, e = 0), validateIntegerRange(e, "pid"), validateIntegerRange(t, "priority", -20, 19), 
  notImplemented(SEE_GITHUB_ISSUE);
 },
 tmpdir: function tmpdir() {
  notImplemented(SEE_GITHUB_ISSUE);
 },
 totalmem,
 type,
 uptime,
 userInfo: function userInfo(e = {
  encoding: "utf-8"
 }) {
  notImplemented(SEE_GITHUB_ISSUE);
 },
 constants: {
  dlopen: {},
  errno: {},
  signals: Deno.Signal,
  priority: {}
 },
 EOL: "windows" == Deno.build.os ? EOL.CRLF : EOL.LF
}, nodeTimers = {
 __proto__: null,
 setTimeout: window.setTimeout,
 clearTimeout: window.clearTimeout,
 setInterval: window.setInterval,
 clearInterval: window.clearInterval,
 setImmediate: (e, ...t) => window.setTimeout(e, 0, ...t),
 clearImmediate: window.clearTimeout
}, hexTable = new Array(256);

for (let e = 0; e < 256; ++e) hexTable[e] = "%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase();

const unescape = decodeURIComponent, escape = encodeURIComponent, nodeQueryString = {
 __proto__: null,
 hexTable,
 parse: parse$3,
 encodeStr: function encodeStr(e, t, n) {
  const r = e.length;
  if (0 === r) return "";
  let o = "", i = 0;
  for (let s = 0; s < r; s++) {
   let a = e.charCodeAt(s);
   if (a < 128) {
    if (1 === t[a]) continue;
    i < s && (o += e.slice(i, s)), i = s + 1, o += n[a];
   } else if (i < s && (o += e.slice(i, s)), a < 2048) i = s + 1, o += n[192 | a >> 6] + n[128 | 63 & a]; else if (a < 55296 || a >= 57344) i = s + 1, 
   o += n[224 | a >> 12] + n[128 | a >> 6 & 63] + n[128 | 63 & a]; else {
    if (++s, s >= r) throw new Deno.errors.InvalidData("invalid URI");
    i = s + 1, a = 65536 + ((1023 & a) << 10 | 1023 & e.charCodeAt(s)), o += n[240 | a >> 18] + n[128 | a >> 12 & 63] + n[128 | a >> 6 & 63] + n[128 | 63 & a];
   }
  }
  return 0 === i ? e : i < r ? o + e.slice(i) : o;
 },
 stringify,
 decode: parse$3,
 encode: stringify,
 unescape,
 escape
};

!function(e) {
 e[e.ascii = 0] = "ascii", e[e.latin1 = 1] = "latin1", e[e.utf16le = 2] = "utf16le";
}(NotImplemented || (NotImplemented = {}));

class StringDecoderBase {
 constructor(e, t) {
  this.encoding = e, this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer.allocUnsafe(t);
 }
}

class Base64Decoder extends StringDecoderBase {
 constructor(e) {
  super(normalizeEncoding$1(e), 3), this.end = base64End, this.fillLast = utf8FillLastIncomplete, 
  this.text = base64Text, this.write = utf8Write;
 }
}

class GenericDecoder extends StringDecoderBase {
 constructor(e) {
  super(normalizeEncoding$1(e), 4), this.end = simpleEnd, this.fillLast = void 0, 
  this.text = utf8Text, this.write = simpleWrite;
 }
}

class Utf8Decoder extends StringDecoderBase {
 constructor(e) {
  super(normalizeEncoding$1(e), 4), this.end = utf8End, this.fillLast = utf8FillLastComplete, 
  this.text = utf8Text, this.write = utf8Write;
 }
}

const nodeStringDecoder = {
 __proto__: null,
 StringDecoder: class StringDecoder {
  constructor(e) {
   let t;
   switch (e) {
   case "utf8":
    t = new Utf8Decoder(e);
    break;

   case "base64":
    t = new Base64Decoder(e);
    break;

   default:
    t = new GenericDecoder(e);
   }
   this.encoding = t.encoding, this.end = t.end, this.fillLast = t.fillLast, this.lastChar = t.lastChar, 
   this.lastNeed = t.lastNeed, this.lastTotal = t.lastTotal, this.text = t.text, this.write = t.write;
  }
 }
}, kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom"), kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");

class NodeInvalidArgTypeError extends TypeError {
 constructor(e, t, n) {
  super(`The "${e}" argument must be of type ${t}. Received ${typeof n}`), this.code = "ERR_INVALID_ARG_TYPE";
 }
}

promisify.custom = kCustomPromisifiedSymbol;

class NodeFalsyValueRejectionError extends Error {
 constructor(e) {
  super("Promise was rejected with falsy value"), this.code = "ERR_FALSY_VALUE_REJECTION", 
  this.reason = e;
 }
}

class NodeInvalidArgTypeError$1 extends TypeError {
 constructor(e) {
  super(`The ${e} argument must be of type function.`), this.code = "ERR_INVALID_ARG_TYPE";
 }
}

class AssertionError extends Error {
 constructor(e) {
  super(e), this.name = "AssertionError";
 }
}

class ERR_INVALID_ARG_TYPE extends TypeError {
 constructor(e, t, n) {
  super(`The "${e}" argument must be of type ${t.toLocaleLowerCase()}. Received ${typeof n} (${n})`), 
  this.code = "ERR_INVALID_ARG_TYPE";
  const {name: r} = this;
  this.name = `${r} [${this.code}]`, this.name = r;
 }
}

class ERR_OUT_OF_RANGE extends RangeError {
 constructor(e, t, n) {
  super(`The value of "${e}" is out of range. It must be ${t}. Received ${n}`), this.code = "ERR_OUT_OF_RANGE";
  const {name: r} = this;
  this.name = `${r} [${this.code}]`, this.name = r;
 }
}

const codes = {
 ERR_INVALID_ARG_TYPE,
 ERR_OUT_OF_RANGE
}, {os} = Deno.build, errorMap = new Map("windows" === os ? [ [ -4093, [ "E2BIG", "argument list too long" ] ], [ -4092, [ "EACCES", "permission denied" ] ], [ -4091, [ "EADDRINUSE", "address already in use" ] ], [ -4090, [ "EADDRNOTAVAIL", "address not available" ] ], [ -4089, [ "EAFNOSUPPORT", "address family not supported" ] ], [ -4088, [ "EAGAIN", "resource temporarily unavailable" ] ], [ -3e3, [ "EAI_ADDRFAMILY", "address family not supported" ] ], [ -3001, [ "EAI_AGAIN", "temporary failure" ] ], [ -3002, [ "EAI_BADFLAGS", "bad ai_flags value" ] ], [ -3013, [ "EAI_BADHINTS", "invalid value for hints" ] ], [ -3003, [ "EAI_CANCELED", "request canceled" ] ], [ -3004, [ "EAI_FAIL", "permanent failure" ] ], [ -3005, [ "EAI_FAMILY", "ai_family not supported" ] ], [ -3006, [ "EAI_MEMORY", "out of memory" ] ], [ -3007, [ "EAI_NODATA", "no address" ] ], [ -3008, [ "EAI_NONAME", "unknown node or service" ] ], [ -3009, [ "EAI_OVERFLOW", "argument buffer overflow" ] ], [ -3014, [ "EAI_PROTOCOL", "resolved protocol is unknown" ] ], [ -3010, [ "EAI_SERVICE", "service not available for socket type" ] ], [ -3011, [ "EAI_SOCKTYPE", "socket type not supported" ] ], [ -4084, [ "EALREADY", "connection already in progress" ] ], [ -4083, [ "EBADF", "bad file descriptor" ] ], [ -4082, [ "EBUSY", "resource busy or locked" ] ], [ -4081, [ "ECANCELED", "operation canceled" ] ], [ -4080, [ "ECHARSET", "invalid Unicode character" ] ], [ -4079, [ "ECONNABORTED", "software caused connection abort" ] ], [ -4078, [ "ECONNREFUSED", "connection refused" ] ], [ -4077, [ "ECONNRESET", "connection reset by peer" ] ], [ -4076, [ "EDESTADDRREQ", "destination address required" ] ], [ -4075, [ "EEXIST", "file already exists" ] ], [ -4074, [ "EFAULT", "bad address in system call argument" ] ], [ -4036, [ "EFBIG", "file too large" ] ], [ -4073, [ "EHOSTUNREACH", "host is unreachable" ] ], [ -4072, [ "EINTR", "interrupted system call" ] ], [ -4071, [ "EINVAL", "invalid argument" ] ], [ -4070, [ "EIO", "i/o error" ] ], [ -4069, [ "EISCONN", "socket is already connected" ] ], [ -4068, [ "EISDIR", "illegal operation on a directory" ] ], [ -4067, [ "ELOOP", "too many symbolic links encountered" ] ], [ -4066, [ "EMFILE", "too many open files" ] ], [ -4065, [ "EMSGSIZE", "message too long" ] ], [ -4064, [ "ENAMETOOLONG", "name too long" ] ], [ -4063, [ "ENETDOWN", "network is down" ] ], [ -4062, [ "ENETUNREACH", "network is unreachable" ] ], [ -4061, [ "ENFILE", "file table overflow" ] ], [ -4060, [ "ENOBUFS", "no buffer space available" ] ], [ -4059, [ "ENODEV", "no such device" ] ], [ -4058, [ "ENOENT", "no such file or directory" ] ], [ -4057, [ "ENOMEM", "not enough memory" ] ], [ -4056, [ "ENONET", "machine is not on the network" ] ], [ -4035, [ "ENOPROTOOPT", "protocol not available" ] ], [ -4055, [ "ENOSPC", "no space left on device" ] ], [ -4054, [ "ENOSYS", "function not implemented" ] ], [ -4053, [ "ENOTCONN", "socket is not connected" ] ], [ -4052, [ "ENOTDIR", "not a directory" ] ], [ -4051, [ "ENOTEMPTY", "directory not empty" ] ], [ -4050, [ "ENOTSOCK", "socket operation on non-socket" ] ], [ -4049, [ "ENOTSUP", "operation not supported on socket" ] ], [ -4048, [ "EPERM", "operation not permitted" ] ], [ -4047, [ "EPIPE", "broken pipe" ] ], [ -4046, [ "EPROTO", "protocol error" ] ], [ -4045, [ "EPROTONOSUPPORT", "protocol not supported" ] ], [ -4044, [ "EPROTOTYPE", "protocol wrong type for socket" ] ], [ -4034, [ "ERANGE", "result too large" ] ], [ -4043, [ "EROFS", "read-only file system" ] ], [ -4042, [ "ESHUTDOWN", "cannot send after transport endpoint shutdown" ] ], [ -4041, [ "ESPIPE", "invalid seek" ] ], [ -4040, [ "ESRCH", "no such process" ] ], [ -4039, [ "ETIMEDOUT", "connection timed out" ] ], [ -4038, [ "ETXTBSY", "text file is busy" ] ], [ -4037, [ "EXDEV", "cross-device link not permitted" ] ], [ -4094, [ "UNKNOWN", "unknown error" ] ], [ -4095, [ "EOF", "end of file" ] ], [ -4033, [ "ENXIO", "no such device or address" ] ], [ -4032, [ "EMLINK", "too many links" ] ], [ -4031, [ "EHOSTDOWN", "host is down" ] ], [ -4030, [ "EREMOTEIO", "remote I/O error" ] ], [ -4029, [ "ENOTTY", "inappropriate ioctl for device" ] ], [ -4028, [ "EFTYPE", "inappropriate file type or format" ] ], [ -4027, [ "EILSEQ", "illegal byte sequence" ] ] ] : "darwin" === os ? [ [ -7, [ "E2BIG", "argument list too long" ] ], [ -13, [ "EACCES", "permission denied" ] ], [ -48, [ "EADDRINUSE", "address already in use" ] ], [ -49, [ "EADDRNOTAVAIL", "address not available" ] ], [ -47, [ "EAFNOSUPPORT", "address family not supported" ] ], [ -35, [ "EAGAIN", "resource temporarily unavailable" ] ], [ -3e3, [ "EAI_ADDRFAMILY", "address family not supported" ] ], [ -3001, [ "EAI_AGAIN", "temporary failure" ] ], [ -3002, [ "EAI_BADFLAGS", "bad ai_flags value" ] ], [ -3013, [ "EAI_BADHINTS", "invalid value for hints" ] ], [ -3003, [ "EAI_CANCELED", "request canceled" ] ], [ -3004, [ "EAI_FAIL", "permanent failure" ] ], [ -3005, [ "EAI_FAMILY", "ai_family not supported" ] ], [ -3006, [ "EAI_MEMORY", "out of memory" ] ], [ -3007, [ "EAI_NODATA", "no address" ] ], [ -3008, [ "EAI_NONAME", "unknown node or service" ] ], [ -3009, [ "EAI_OVERFLOW", "argument buffer overflow" ] ], [ -3014, [ "EAI_PROTOCOL", "resolved protocol is unknown" ] ], [ -3010, [ "EAI_SERVICE", "service not available for socket type" ] ], [ -3011, [ "EAI_SOCKTYPE", "socket type not supported" ] ], [ -37, [ "EALREADY", "connection already in progress" ] ], [ -9, [ "EBADF", "bad file descriptor" ] ], [ -16, [ "EBUSY", "resource busy or locked" ] ], [ -89, [ "ECANCELED", "operation canceled" ] ], [ -4080, [ "ECHARSET", "invalid Unicode character" ] ], [ -53, [ "ECONNABORTED", "software caused connection abort" ] ], [ -61, [ "ECONNREFUSED", "connection refused" ] ], [ -54, [ "ECONNRESET", "connection reset by peer" ] ], [ -39, [ "EDESTADDRREQ", "destination address required" ] ], [ -17, [ "EEXIST", "file already exists" ] ], [ -14, [ "EFAULT", "bad address in system call argument" ] ], [ -27, [ "EFBIG", "file too large" ] ], [ -65, [ "EHOSTUNREACH", "host is unreachable" ] ], [ -4, [ "EINTR", "interrupted system call" ] ], [ -22, [ "EINVAL", "invalid argument" ] ], [ -5, [ "EIO", "i/o error" ] ], [ -56, [ "EISCONN", "socket is already connected" ] ], [ -21, [ "EISDIR", "illegal operation on a directory" ] ], [ -62, [ "ELOOP", "too many symbolic links encountered" ] ], [ -24, [ "EMFILE", "too many open files" ] ], [ -40, [ "EMSGSIZE", "message too long" ] ], [ -63, [ "ENAMETOOLONG", "name too long" ] ], [ -50, [ "ENETDOWN", "network is down" ] ], [ -51, [ "ENETUNREACH", "network is unreachable" ] ], [ -23, [ "ENFILE", "file table overflow" ] ], [ -55, [ "ENOBUFS", "no buffer space available" ] ], [ -19, [ "ENODEV", "no such device" ] ], [ -2, [ "ENOENT", "no such file or directory" ] ], [ -12, [ "ENOMEM", "not enough memory" ] ], [ -4056, [ "ENONET", "machine is not on the network" ] ], [ -42, [ "ENOPROTOOPT", "protocol not available" ] ], [ -28, [ "ENOSPC", "no space left on device" ] ], [ -78, [ "ENOSYS", "function not implemented" ] ], [ -57, [ "ENOTCONN", "socket is not connected" ] ], [ -20, [ "ENOTDIR", "not a directory" ] ], [ -66, [ "ENOTEMPTY", "directory not empty" ] ], [ -38, [ "ENOTSOCK", "socket operation on non-socket" ] ], [ -45, [ "ENOTSUP", "operation not supported on socket" ] ], [ -1, [ "EPERM", "operation not permitted" ] ], [ -32, [ "EPIPE", "broken pipe" ] ], [ -100, [ "EPROTO", "protocol error" ] ], [ -43, [ "EPROTONOSUPPORT", "protocol not supported" ] ], [ -41, [ "EPROTOTYPE", "protocol wrong type for socket" ] ], [ -34, [ "ERANGE", "result too large" ] ], [ -30, [ "EROFS", "read-only file system" ] ], [ -58, [ "ESHUTDOWN", "cannot send after transport endpoint shutdown" ] ], [ -29, [ "ESPIPE", "invalid seek" ] ], [ -3, [ "ESRCH", "no such process" ] ], [ -60, [ "ETIMEDOUT", "connection timed out" ] ], [ -26, [ "ETXTBSY", "text file is busy" ] ], [ -18, [ "EXDEV", "cross-device link not permitted" ] ], [ -4094, [ "UNKNOWN", "unknown error" ] ], [ -4095, [ "EOF", "end of file" ] ], [ -6, [ "ENXIO", "no such device or address" ] ], [ -31, [ "EMLINK", "too many links" ] ], [ -64, [ "EHOSTDOWN", "host is down" ] ], [ -4030, [ "EREMOTEIO", "remote I/O error" ] ], [ -25, [ "ENOTTY", "inappropriate ioctl for device" ] ], [ -79, [ "EFTYPE", "inappropriate file type or format" ] ], [ -92, [ "EILSEQ", "illegal byte sequence" ] ] ] : "linux" === os ? [ [ -7, [ "E2BIG", "argument list too long" ] ], [ -13, [ "EACCES", "permission denied" ] ], [ -98, [ "EADDRINUSE", "address already in use" ] ], [ -99, [ "EADDRNOTAVAIL", "address not available" ] ], [ -97, [ "EAFNOSUPPORT", "address family not supported" ] ], [ -11, [ "EAGAIN", "resource temporarily unavailable" ] ], [ -3e3, [ "EAI_ADDRFAMILY", "address family not supported" ] ], [ -3001, [ "EAI_AGAIN", "temporary failure" ] ], [ -3002, [ "EAI_BADFLAGS", "bad ai_flags value" ] ], [ -3013, [ "EAI_BADHINTS", "invalid value for hints" ] ], [ -3003, [ "EAI_CANCELED", "request canceled" ] ], [ -3004, [ "EAI_FAIL", "permanent failure" ] ], [ -3005, [ "EAI_FAMILY", "ai_family not supported" ] ], [ -3006, [ "EAI_MEMORY", "out of memory" ] ], [ -3007, [ "EAI_NODATA", "no address" ] ], [ -3008, [ "EAI_NONAME", "unknown node or service" ] ], [ -3009, [ "EAI_OVERFLOW", "argument buffer overflow" ] ], [ -3014, [ "EAI_PROTOCOL", "resolved protocol is unknown" ] ], [ -3010, [ "EAI_SERVICE", "service not available for socket type" ] ], [ -3011, [ "EAI_SOCKTYPE", "socket type not supported" ] ], [ -114, [ "EALREADY", "connection already in progress" ] ], [ -9, [ "EBADF", "bad file descriptor" ] ], [ -16, [ "EBUSY", "resource busy or locked" ] ], [ -125, [ "ECANCELED", "operation canceled" ] ], [ -4080, [ "ECHARSET", "invalid Unicode character" ] ], [ -103, [ "ECONNABORTED", "software caused connection abort" ] ], [ -111, [ "ECONNREFUSED", "connection refused" ] ], [ -104, [ "ECONNRESET", "connection reset by peer" ] ], [ -89, [ "EDESTADDRREQ", "destination address required" ] ], [ -17, [ "EEXIST", "file already exists" ] ], [ -14, [ "EFAULT", "bad address in system call argument" ] ], [ -27, [ "EFBIG", "file too large" ] ], [ -113, [ "EHOSTUNREACH", "host is unreachable" ] ], [ -4, [ "EINTR", "interrupted system call" ] ], [ -22, [ "EINVAL", "invalid argument" ] ], [ -5, [ "EIO", "i/o error" ] ], [ -106, [ "EISCONN", "socket is already connected" ] ], [ -21, [ "EISDIR", "illegal operation on a directory" ] ], [ -40, [ "ELOOP", "too many symbolic links encountered" ] ], [ -24, [ "EMFILE", "too many open files" ] ], [ -90, [ "EMSGSIZE", "message too long" ] ], [ -36, [ "ENAMETOOLONG", "name too long" ] ], [ -100, [ "ENETDOWN", "network is down" ] ], [ -101, [ "ENETUNREACH", "network is unreachable" ] ], [ -23, [ "ENFILE", "file table overflow" ] ], [ -105, [ "ENOBUFS", "no buffer space available" ] ], [ -19, [ "ENODEV", "no such device" ] ], [ -2, [ "ENOENT", "no such file or directory" ] ], [ -12, [ "ENOMEM", "not enough memory" ] ], [ -64, [ "ENONET", "machine is not on the network" ] ], [ -92, [ "ENOPROTOOPT", "protocol not available" ] ], [ -28, [ "ENOSPC", "no space left on device" ] ], [ -38, [ "ENOSYS", "function not implemented" ] ], [ -107, [ "ENOTCONN", "socket is not connected" ] ], [ -20, [ "ENOTDIR", "not a directory" ] ], [ -39, [ "ENOTEMPTY", "directory not empty" ] ], [ -88, [ "ENOTSOCK", "socket operation on non-socket" ] ], [ -95, [ "ENOTSUP", "operation not supported on socket" ] ], [ -1, [ "EPERM", "operation not permitted" ] ], [ -32, [ "EPIPE", "broken pipe" ] ], [ -71, [ "EPROTO", "protocol error" ] ], [ -93, [ "EPROTONOSUPPORT", "protocol not supported" ] ], [ -91, [ "EPROTOTYPE", "protocol wrong type for socket" ] ], [ -34, [ "ERANGE", "result too large" ] ], [ -30, [ "EROFS", "read-only file system" ] ], [ -108, [ "ESHUTDOWN", "cannot send after transport endpoint shutdown" ] ], [ -29, [ "ESPIPE", "invalid seek" ] ], [ -3, [ "ESRCH", "no such process" ] ], [ -110, [ "ETIMEDOUT", "connection timed out" ] ], [ -26, [ "ETXTBSY", "text file is busy" ] ], [ -18, [ "EXDEV", "cross-device link not permitted" ] ], [ -4094, [ "UNKNOWN", "unknown error" ] ], [ -4095, [ "EOF", "end of file" ] ], [ -6, [ "ENXIO", "no such device or address" ] ], [ -31, [ "EMLINK", "too many links" ] ], [ -112, [ "EHOSTDOWN", "host is down" ] ], [ -121, [ "EREMOTEIO", "remote I/O error" ] ], [ -25, [ "ENOTTY", "inappropriate ioctl for device" ] ], [ -4028, [ "EFTYPE", "inappropriate file type or format" ] ], [ -84, [ "EILSEQ", "illegal byte sequence" ] ] ] : function unreachable() {
 throw new AssertionError("unreachable");
}()), _toString = Object.prototype.toString, _isObjectLike = e => null !== e && "object" == typeof e, _isFunctionLike = e => null !== e && "function" == typeof e, _util_types = {
 __proto__: null,
 isAnyArrayBuffer: function isAnyArrayBuffer(e) {
  return _isObjectLike(e) && ("[object ArrayBuffer]" === _toString.call(e) || "[object SharedArrayBuffer]" === _toString.call(e));
 },
 isArrayBufferView: function isArrayBufferView(e) {
  return ArrayBuffer.isView(e);
 },
 isArgumentsObject: function isArgumentsObject(e) {
  return _isObjectLike(e) && "[object Arguments]" === _toString.call(e);
 },
 isArrayBuffer: function isArrayBuffer(e) {
  return _isObjectLike(e) && "[object ArrayBuffer]" === _toString.call(e);
 },
 isAsyncFunction: function isAsyncFunction(e) {
  return _isFunctionLike(e) && "[object AsyncFunction]" === _toString.call(e);
 },
 isBigInt64Array: function isBigInt64Array(e) {
  return _isObjectLike(e) && "[object BigInt64Array]" === _toString.call(e);
 },
 isBigUint64Array: function isBigUint64Array(e) {
  return _isObjectLike(e) && "[object BigUint64Array]" === _toString.call(e);
 },
 isBooleanObject,
 isBoxedPrimitive: function isBoxedPrimitive(e) {
  return isBooleanObject(e) || isStringObject(e) || isNumberObject(e) || isSymbolObject(e) || isBigIntObject(e);
 },
 isDataView: function isDataView(e) {
  return _isObjectLike(e) && "[object DataView]" === _toString.call(e);
 },
 isDate: function isDate(e) {
  return _isObjectLike(e) && "[object Date]" === _toString.call(e);
 },
 isFloat32Array: function isFloat32Array(e) {
  return _isObjectLike(e) && "[object Float32Array]" === _toString.call(e);
 },
 isFloat64Array: function isFloat64Array(e) {
  return _isObjectLike(e) && "[object Float64Array]" === _toString.call(e);
 },
 isGeneratorFunction: function isGeneratorFunction(e) {
  return _isFunctionLike(e) && "[object GeneratorFunction]" === _toString.call(e);
 },
 isGeneratorObject: function isGeneratorObject(e) {
  return _isObjectLike(e) && "[object Generator]" === _toString.call(e);
 },
 isInt8Array: function isInt8Array(e) {
  return _isObjectLike(e) && "[object Int8Array]" === _toString.call(e);
 },
 isInt16Array: function isInt16Array(e) {
  return _isObjectLike(e) && "[object Int16Array]" === _toString.call(e);
 },
 isInt32Array: function isInt32Array(e) {
  return _isObjectLike(e) && "[object Int32Array]" === _toString.call(e);
 },
 isMap: function isMap(e) {
  return _isObjectLike(e) && "[object Map]" === _toString.call(e);
 },
 isMapIterator: function isMapIterator(e) {
  return _isObjectLike(e) && "[object Map Iterator]" === _toString.call(e);
 },
 isModuleNamespaceObject: function isModuleNamespaceObject(e) {
  return _isObjectLike(e) && "[object Module]" === _toString.call(e);
 },
 isNativeError: function isNativeError(e) {
  return _isObjectLike(e) && "[object Error]" === _toString.call(e);
 },
 isNumberObject,
 isBigIntObject,
 isPromise: function isPromise(e) {
  return _isObjectLike(e) && "[object Promise]" === _toString.call(e);
 },
 isRegExp: function isRegExp(e) {
  return _isObjectLike(e) && "[object RegExp]" === _toString.call(e);
 },
 isSet: function isSet(e) {
  return _isObjectLike(e) && "[object Set]" === _toString.call(e);
 },
 isSetIterator: function isSetIterator(e) {
  return _isObjectLike(e) && "[object Set Iterator]" === _toString.call(e);
 },
 isSharedArrayBuffer: function isSharedArrayBuffer(e) {
  return _isObjectLike(e) && "[object SharedArrayBuffer]" === _toString.call(e);
 },
 isStringObject,
 isSymbolObject,
 isTypedArray: function isTypedArray(e) {
  return _isObjectLike(e) && /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/.test(_toString.call(e));
 },
 isUint8Array: function isUint8Array(e) {
  return _isObjectLike(e) && "[object Uint8Array]" === _toString.call(e);
 },
 isUint8ClampedArray: function isUint8ClampedArray(e) {
  return _isObjectLike(e) && "[object Uint8ClampedArray]" === _toString.call(e);
 },
 isUint16Array: function isUint16Array(e) {
  return _isObjectLike(e) && "[object Uint16Array]" === _toString.call(e);
 },
 isUint32Array: function isUint32Array(e) {
  return _isObjectLike(e) && "[object Uint32Array]" === _toString.call(e);
 },
 isWeakMap: function isWeakMap(e) {
  return _isObjectLike(e) && "[object WeakMap]" === _toString.call(e);
 },
 isWeakSet: function isWeakSet(e) {
  return _isObjectLike(e) && "[object WeakSet]" === _toString.call(e);
 }
}, NumberIsSafeInteger = Number.isSafeInteger, {ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE$1, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE$1} = codes, DEFAULT_INSPECT_OPTIONS = {
 showHidden: !1,
 depth: 2,
 colors: !1,
 customInspect: !0,
 showProxy: !1,
 maxArrayLength: 100,
 maxStringLength: 1 / 0,
 breakLength: 80,
 compact: 3,
 sorted: !1,
 getters: !1
};

inspect.defaultOptions = DEFAULT_INSPECT_OPTIONS, inspect.custom = Deno.customInspect;

const nodeUtil = {
 __proto__: null,
 types: _util_types,
 inspect,
 isArray: function isArray(e) {
  return Array.isArray(e);
 },
 isBoolean: function isBoolean(e) {
  return "boolean" == typeof e || e instanceof Boolean;
 },
 isNull: function isNull(e) {
  return null === e;
 },
 isNullOrUndefined: function isNullOrUndefined(e) {
  return null == e;
 },
 isNumber: function isNumber(e) {
  return "number" == typeof e || e instanceof Number;
 },
 isString: function isString(e) {
  return "string" == typeof e || e instanceof String;
 },
 isSymbol: function isSymbol(e) {
  return "symbol" == typeof e;
 },
 isUndefined: function isUndefined(e) {
  return void 0 === e;
 },
 isObject: function isObject(e) {
  return null !== e && "object" == typeof e;
 },
 isError: function isError(e) {
  return e instanceof Error;
 },
 isFunction: function isFunction(e) {
  return "function" == typeof e;
 },
 isRegExp: function isRegExp$1(e) {
  return e instanceof RegExp;
 },
 isPrimitive: function isPrimitive(e) {
  return null === e || "object" != typeof e && "function" != typeof e;
 },
 getSystemErrorName: function getSystemErrorName(e) {
  var t;
  if ("number" != typeof e) throw new ERR_INVALID_ARG_TYPE$1("err", "number", e);
  if (e >= 0 || !NumberIsSafeInteger(e)) throw new ERR_OUT_OF_RANGE$1("err", "a negative integer", e);
  return null === (t = errorMap.get(e)) || void 0 === t ? void 0 : t[0];
 },
 TextDecoder: _TextDecoder,
 TextEncoder: _TextEncoder,
 promisify,
 callbackify: function callbackify(e) {
  if ("function" != typeof e) throw new NodeInvalidArgTypeError$1('"original"');
  const t = function(...t) {
   const n = t.pop();
   if ("function" != typeof n) throw new NodeInvalidArgTypeError$1("last");
   const r = (...e) => {
    n.apply(this, e);
   };
   e.apply(this, t).then(e => {
    queueMicrotask(r.bind(this, null, e));
   }, e => {
    e = e || new NodeFalsyValueRejectionError(e), queueMicrotask(r.bind(this, e));
   });
  }, n = Object.getOwnPropertyDescriptors(e);
  return "number" == typeof n.length.value && n.length.value++, "string" == typeof n.name.value && (n.name.value += "Callbackified"), 
  Object.defineProperties(t, n), t;
 }
}, isWindows$1 = "windows" === Deno.build.os, forwardSlashRegEx = /\//g, percentRegEx = /%/g, backslashRegEx = /\\/g, newlineRegEx = /\n/g, carriageReturnRegEx = /\r/g, tabRegEx = /\t/g, CHAR_FORWARD_SLASH$1 = "/".charCodeAt(0), CHAR_BACKWARD_SLASH$1 = "\\".charCodeAt(0), CHAR_COLON$1 = ":".charCodeAt(0), isWindows$2 = "windows" == Deno.build.os, relativeResolveCache = Object.create(null);

let requireDepth = 0, statCache = null;

class Module {
 constructor(e = "", t) {
  this.id = e, this.exports = {}, this.parent = t || null, updateChildren(t || null, this, !1), 
  this.filename = null, this.loaded = !1, this.children = [], this.paths = [], this.path = dirname$2(e);
 }
 require(e) {
  if ("" === e) throw new Error(`id '${e}' must be a non-empty string`);
  requireDepth++;
  try {
   return Module._load(e, this, !1);
  } finally {
   requireDepth--;
  }
 }
 load(e) {
  assert(!this.loaded), this.filename = e, this.paths = Module._nodeModulePaths(dirname$2(e));
  const t = function n(e) {
   const t = basename$2(e);
   let n, r, o = 0;
   for (;-1 !== (r = t.indexOf(".", o)); ) if (o = r + 1, 0 !== r && (n = t.slice(r), 
   Module._extensions[n])) return n;
   return ".js";
  }(e);
  Module._extensions[t](this, e), this.loaded = !0;
 }
 _compile(e, t) {
  const n = function r(e, t) {
   const n = Module.wrap(t), [r, o] = Deno.core.evalContext(n, e);
   if (o) throw o;
   return r;
  }(t, e), o = dirname$2(t), i = makeRequireFunction(this), s = this.exports, a = s;
  0 === requireDepth && (statCache = new Map);
  const l = n.call(a, s, i, this, t, o);
  return 0 === requireDepth && (statCache = null), l;
 }
 static _resolveLookupPaths(e, t) {
  if ("." !== e.charAt(0) || e.length > 1 && "." !== e.charAt(1) && "/" !== e.charAt(1) && (!isWindows$2 || "\\" !== e.charAt(1))) {
   let e = modulePaths;
   return null !== t && t.paths && t.paths.length && (e = t.paths.concat(e)), e.length > 0 ? e : null;
  }
  return t && t.id && t.filename ? [ dirname$2(t.filename) ] : [ "." ].concat(Module._nodeModulePaths("."), modulePaths);
 }
 static _resolveFilename(e, t, n, r) {
  if (function o(e) {
   return nativeModulePolyfill.has(e);
  }(e)) return e;
  let i;
  if ("object" == typeof r && null !== r) if (Array.isArray(r.paths)) if (e.startsWith("./") || e.startsWith("../") || isWindows$2 && e.startsWith(".\\") || e.startsWith("..\\")) i = r.paths; else {
   const t = new Module("", null);
   i = [];
   for (let n = 0; n < r.paths.length; n++) {
    const o = r.paths[n];
    t.paths = Module._nodeModulePaths(o);
    const s = Module._resolveLookupPaths(e, t);
    for (let e = 0; e < s.length; e++) i.includes(s[e]) || i.push(s[e]);
   }
  } else {
   if (void 0 !== r.paths) throw new Error("options.paths is invalid");
   i = Module._resolveLookupPaths(e, t);
  } else i = Module._resolveLookupPaths(e, t);
  const s = Module._findPath(e, i, n);
  if (!s) {
   const n = [];
   for (let e = t; e; e = e.parent) n.push(e.filename || e.id);
   let r = `Cannot find module '${e}'`;
   n.length > 0 && (r = r + "\nRequire stack:\n- " + n.join("\n- "));
   const o = new Error(r);
   throw o.code = "MODULE_NOT_FOUND", o.requireStack = n, o;
  }
  return s;
 }
 static _findPath(e, t, n) {
  const r = isAbsolute$2(e);
  if (r) t = [ "" ]; else if (!t || 0 === t.length) return !1;
  const o = e + "\0" + (1 === t.length ? t[0] : t.join("\0")), i = Module._pathCache[o];
  if (i) return i;
  let s, a = e.length > 0 && e.charCodeAt(e.length - 1) === CHAR_FORWARD_SLASH$1;
  a || (a = /(?:^|\/)\.?\.$/.test(e));
  for (let n = 0; n < t.length; n++) {
   const i = t[n];
   if (i && stat$1(i) < 1) continue;
   const l = resolveExports(i, e, r);
   let c;
   const u = stat$1(l);
   if (a || (0 === u && (c = toRealPath(l)), c || (void 0 === s && (s = Object.keys(Module._extensions)), 
   c = tryExtensions(l, s))), c || 1 !== u || (void 0 === s && (s = Object.keys(Module._extensions)), 
   c = tryPackage(l, s)), c) return Module._pathCache[o] = c, c;
  }
  return !1;
 }
 static _load(e, t, n) {
  let r;
  if (t) {
   r = `${t.path}\0${e}`;
   const n = relativeResolveCache[r];
   if (void 0 !== n) {
    const e = Module._cache[n];
    if (void 0 !== e) return updateChildren(t, e, !0), e.loaded ? e.exports : getExportsForCircularRequire(e);
    delete relativeResolveCache[r];
   }
  }
  const o = Module._resolveFilename(e, t, n), i = Module._cache[o];
  if (void 0 !== i) return updateChildren(t, i, !0), i.loaded ? i.exports : getExportsForCircularRequire(i);
  const s = function a(e, t) {
   return nativeModulePolyfill.get(t);
  }(0, e);
  if (s) return s.exports;
  const l = new Module(o, t);
  n && (l.id = "."), Module._cache[o] = l, void 0 !== t && (assert(r), relativeResolveCache[r] = o);
  let c = !0;
  try {
   l.load(o), c = !1;
  } finally {
   c ? (delete Module._cache[o], void 0 !== t && (assert(r), delete relativeResolveCache[r])) : l.exports && Object.getPrototypeOf(l.exports) === CircularRequirePrototypeWarningProxy && Object.setPrototypeOf(l.exports, PublicObjectPrototype);
  }
  return l.exports;
 }
 static wrap(e) {
  return `${Module.wrapper[0]}${e}${Module.wrapper[1]}`;
 }
 static _nodeModulePaths(e) {
  if (isWindows$2) {
   if ((e = resolve$2(e)).charCodeAt(e.length - 1) === CHAR_BACKWARD_SLASH$1 && e.charCodeAt(e.length - 2) === CHAR_COLON$1) return [ e + "node_modules" ];
   const t = [];
   for (let n = e.length - 1, r = 0, o = e.length; n >= 0; --n) {
    const i = e.charCodeAt(n);
    i === CHAR_BACKWARD_SLASH$1 || i === CHAR_FORWARD_SLASH$1 || i === CHAR_COLON$1 ? (r !== nmLen && t.push(e.slice(0, o) + "\\node_modules"), 
    o = n, r = 0) : -1 !== r && (nmChars[r] === i ? ++r : r = -1);
   }
   return t;
  }
  {
   if ("/" === (e = resolve$2(e))) return [ "/node_modules" ];
   const t = [];
   for (let n = e.length - 1, r = 0, o = e.length; n >= 0; --n) {
    const i = e.charCodeAt(n);
    i === CHAR_FORWARD_SLASH$1 ? (r !== nmLen && t.push(e.slice(0, o) + "/node_modules"), 
    o = n, r = 0) : -1 !== r && (nmChars[r] === i ? ++r : r = -1);
   }
   return t.push("/node_modules"), t;
  }
 }
 static createRequire(e) {
  let t;
  if (e instanceof URL || "string" == typeof e && !isAbsolute$2(e)) t = fileURLToPath(e); else {
   if ("string" != typeof e) throw new Error("filename should be a string");
   t = e;
  }
  return function n(e) {
   const t = e.endsWith("/") || isWindows$2 && e.endsWith("\\") ? join$2(e, "noop.js") : e, n = new Module(t);
   return n.filename = t, n.paths = Module._nodeModulePaths(n.path), makeRequireFunction(n);
  }(t);
 }
 static _initPaths() {
  const e = Deno.env.get("HOME"), t = Deno.env.get("NODE_PATH");
  let n = [];
  e && (n.unshift(resolve$2(e, ".node_libraries")), n.unshift(resolve$2(e, ".node_modules"))), 
  t && (n = t.split(delimiter$2).filter((function e(t) {
   return !!t;
  })).concat(n)), modulePaths = n, Module.globalPaths = modulePaths.slice(0);
 }
 static _preloadModules(e) {
  if (!Array.isArray(e)) return;
  const t = new Module("internal/preload", null);
  try {
   t.paths = Module._nodeModulePaths(Deno.cwd());
  } catch (e) {
   if ("ENOENT" !== e.code) throw e;
  }
  for (let n = 0; n < e.length; n++) t.require(e[n]);
 }
}

Module.builtinModules = [], Module._extensions = Object.create(null), Module._cache = Object.create(null), 
Module._pathCache = Object.create(null), Module.globalPaths = [], Module.wrapper = [ "(function (exports, require, module, __filename, __dirname) { ", "\n});" ];

const nativeModulePolyfill = new Map;

nativeModulePolyfill.set("buffer", createNativeModule("buffer", nodeBuffer)), nativeModulePolyfill.set("events", createNativeModule("events", nodeEvents)), 
nativeModulePolyfill.set("fs", createNativeModule("fs", nodeFs)), nativeModulePolyfill.set("os", createNativeModule("os", nodeOs)), 
nativeModulePolyfill.set("path", createNativeModule("path", nodePath)), nativeModulePolyfill.set("querystring", createNativeModule("querystring", nodeQueryString)), 
nativeModulePolyfill.set("string_decoder", createNativeModule("string_decoder", nodeStringDecoder)), 
nativeModulePolyfill.set("timers", createNativeModule("timers", nodeTimers)), nativeModulePolyfill.set("util", createNativeModule("util", nodeUtil));

for (const e of nativeModulePolyfill.keys()) Module.builtinModules.push(e);

let modulePaths = [];

const packageJsonCache = new Map, EXPORTS_PATTERN = /^((?:@[^/\\%]+\/)?[^./\\%][^/\\%]*)(\/.*)?$/, nmChars = [ 115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110 ], nmLen = nmChars.length, CircularRequirePrototypeWarningProxy = new Proxy({}, {
 get(e, t) {
  if (t in e) return e[t];
  emitCircularRequireWarning(t);
 },
 getOwnPropertyDescriptor(e, t) {
  if (Object.prototype.hasOwnProperty.call(e, t)) return Object.getOwnPropertyDescriptor(e, t);
  emitCircularRequireWarning(t);
 }
}), PublicObjectPrototype = window.Object.prototype;

Module._extensions[".js"] = (e, t) => {
 if (t.endsWith(".js")) {
  const e = function n(e) {
   const t = e.indexOf(sep$2);
   let n;
   for (;(n = e.lastIndexOf(sep$2)) > t; ) {
    if ((e = e.slice(0, n)).endsWith(sep$2 + "node_modules")) return !1;
    const t = readPackage(e);
    if (t) return {
     path: e,
     data: t
    };
   }
   return !1;
  }(t);
  if (!1 !== e && e.data && "module" === e.data.type) throw new Error("Importing ESM module");
 }
 const r = (new TextDecoder).decode(Deno.readFileSync(t));
 e._compile(r, t);
}, Module._extensions[".json"] = (e, t) => {
 const n = (new TextDecoder).decode(Deno.readFileSync(t));
 try {
  e.exports = JSON.parse(function r(e) {
   return 65279 === e.charCodeAt(0) && (e = e.slice(1)), e;
  }(n));
 } catch (e) {
  throw e.message = t + ": " + e.message, e;
 }
};

const createRequire = Module.createRequire;

Object.assign(nodeFs, {
 stat: (...e) => {
  const t = e[0], n = e.length > 2 ? e[2] : e[1];
  try {
   const e = Deno.statSync(t);
   n && n(null, {
    isFile: () => e.isFile,
    isDirectory: () => e.isDirectory,
    isSymbolicLink: () => e.isSymlink,
    size: e.size
   });
  } catch (e) {
   n && n(e);
  }
 },
 statSync: e => {
  const t = Deno.statSync(e);
  return {
   isFile: () => t.isFile,
   isDirectory: () => t.isDirectory,
   isSymbolicLink: () => t.isSymlink,
   size: t.size
  };
 }
});

const applyNodeCompat = e => {
 globalThis.process = process;
 const t = createRequire(join$2(e.fromDir, "noop.js"));
 globalThis.require = t;
};

export { applyNodeCompat };