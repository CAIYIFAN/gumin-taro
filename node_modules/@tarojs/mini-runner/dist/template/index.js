"use strict";
/**
 * 这里我们需要关心的小程序种类有两类：
 * 1. 模板递归：
 *  - 支持：tmpl0 套 tmpl0
 *  - 不支持：这就使得我们必须生成多级的模板，tmpl0 套 tmpl1，tmpl1 套 tmpl2……
 *           直到超过阈值 N (N = config.miniapp.baseLevel) tmplN 会套组件 comp，组件 comp 重新再套 tmpl0。
 * 2. 小程序脚本语言（wxs, sjs, etc...）：
 *  - 支持：可以在模板使用函数缩减模板大小或提高性能（存疑），例如判断一个值是不是假值（falsy value）。
 *         将来或许会把数据序列化^1 的操作也放到小程序脚本语言里。
 *  - 不支持：使用纯 *xml 语法
 *
 * ^1: packages/taro-runtime/src/hydrate.ts
*/
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("@tarojs/shared");
const helper_1 = require("@tarojs/helper");
const adapters_1 = require("./adapters");
const component_1 = require("./component");
const voidElements = new Set([
    'progress',
    'icon',
    'rich-text',
    'input',
    'textarea',
    'slider',
    'switch',
    'audio',
    'live-player',
    'live-pusher',
    'video'
]);
const swanSpecialAttrs = {
    'scroll-view': ['scrollTop', 'scrollLeft', 'scrollIntoView'],
    'movable-view': ['x', 'y'],
    slider: ['value'],
    input: ['value'],
    textarea: ['value']
};
function buildAttribute(attrs, nodeName) {
    function getValue(key) {
        if (adapters_1.Adapter.type === helper_1.PLATFORMS.SWAN && shared_1.isArray(swanSpecialAttrs[nodeName]) && swanSpecialAttrs[nodeName].includes(key)) {
            return `= ${attrs[key]} =`;
        }
        return `{ ${attrs[key]} }`;
    }
    return Object.keys(attrs)
        .map(k => `${k}="${k.startsWith('bind') || k.startsWith('on') ? attrs[k] : `{${getValue(k)}}`}" `)
        .join('');
}
exports.buildAttribute = buildAttribute;
const dataKeymap = (keymap) => {
    return adapters_1.Adapter.type === helper_1.PLATFORMS.SWAN ? `{ ${keymap} }` : keymap;
};
function buildStandardComponentTemplate(comp, level, supportRecursive) {
    const nextLevel = supportRecursive ? 0 : level + 1;
    const child = adapters_1.Adapter.type === helper_1.PLATFORMS.SWAN && comp.nodeName === 'text'
        ? `<block>{{ i.${"cn" /* Childnodes */}[index].${"v" /* Text */} }}</block>`
        : `<template is="tmpl_${nextLevel}_${"container" /* Container */}" data="{{${dataKeymap('i: item')}}}" />`;
    const nodeName = comp.nodeName === 'slot' || comp.nodeName === 'slot-view' ? 'view' : comp.nodeName;
    const children = voidElements.has(comp.nodeName)
        ? ''
        : `
    ${adapters_1.Adapter.type === helper_1.PLATFORMS.ALIPAY && comp.nodeName === 'picker' ? '<view>\n' : ''}<block ${adapters_1.Adapter.for}="{{i.${"cn" /* Childnodes */}}}" ${adapters_1.Adapter.key}="id">
      ${child}
    </block>${adapters_1.Adapter.type === helper_1.PLATFORMS.ALIPAY && comp.nodeName === 'picker' ? '\n</view>' : ''}
  `;
    return `
<template name="tmpl_${level}_${comp.nodeName}">
  <${nodeName} ${buildAttribute(comp.attributes, comp.nodeName)} id="{{ i.uid }}">${children}</${nodeName}>
</template>
`;
}
function buildXsTemplate() {
    let xs = '';
    if (adapters_1.Adapter.type === helper_1.PLATFORMS.WEAPP || adapters_1.Adapter.type === helper_1.PLATFORMS.QQ) {
        xs = `<wxs module="xs" src="./utils.${adapters_1.Adapter.xs}" />`;
    }
    else if (adapters_1.Adapter.type === helper_1.PLATFORMS.ALIPAY) {
        xs = `<import-sjs name="xs" from="./utils.${adapters_1.Adapter.xs}" />`;
    }
    else if (adapters_1.Adapter.type === helper_1.PLATFORMS.SWAN) {
        xs = `<import-sjs module="xs" src="./utils.${adapters_1.Adapter.xs}" />`;
    }
    return xs;
}
function buildXScript() {
    const exportExpr = adapters_1.Adapter.type === helper_1.PLATFORMS.ALIPAY ? 'export default' : 'module.exports =';
    return `${exportExpr} {
  c: function(i, prefix) {
    var s = i.focus !== undefined ? 'focus' : 'blur'
    return prefix + i.${"nn" /* NodeName */} + '_' + s
  },
  d: function (i, v) {
    return i === undefined ? v : i
  }
}`;
}
exports.buildXScript = buildXScript;
function buildComponentTemplate(comp, level, supportRecursive, supportXS) {
    return shared_1.focusComponents.has(comp.nodeName)
        ? buildFocusComponentTemplte(comp, level, supportXS)
        : buildStandardComponentTemplate(comp, level, supportRecursive);
}
function buildFocusComponentTemplte(comp, level, supportXS) {
    const attrs = Object.assign({}, comp.attributes);
    const templateName = supportXS
        ? `xs.c(i, 'tmpl_${level}_')`
        : `i.focus ? 'tmpl_${level}_${comp.nodeName}_focus' : 'tmpl_${level}_${comp.nodeName}_blur'`;
    delete attrs.focus;
    return `
<template name="tmpl_${level}_${comp.nodeName}">
  <template is="{{ ${templateName} }}" data="{{${dataKeymap('i: i')}}}" />
</template>

<template name="tmpl_${level}_${comp.nodeName}_focus">
  <${comp.nodeName} ${buildAttribute(comp.attributes, comp.nodeName)} id="{{ i.uid }}" />
</template>

<template name="tmpl_${level}_${comp.nodeName}_blur">
  <${comp.nodeName} ${buildAttribute(attrs, comp.nodeName)} id="{{ i.uid }}" />
</template>
`;
}
function buildPlainTextTemplate(level) {
    return `
<template name="tmpl_${level}_#text" data="{{${dataKeymap('i: i')}}}">
  <block>{{i.${"v" /* Text */}}}</block>
</template>
`;
}
function buildContainerTemplate(level, restart = false) {
    let tmpl = '';
    if (restart) {
        tmpl = '<comp i="{{i}}" />';
    }
    else {
        tmpl = `<template is="{{'tmpl_${level}_' + i.${"nn" /* NodeName */}}}" data="{{${dataKeymap('i: i')}}}" />`;
    }
    return `
<template name="tmpl_${level}_${"container" /* Container */}" data="{{${dataKeymap('i: i')}}}">
  ${tmpl}
</template>
`;
}
function buildTemplate(level, supportRecursive, supportXS, restart = false) {
    const miniComponents = shared_1.createMiniComponents(shared_1.internalComponents, adapters_1.Adapter.type);
    const components = Object.keys(miniComponents).filter(c => component_1.componentConfig.includes.size && !component_1.componentConfig.includeAll ? component_1.componentConfig.includes.has(c) : true);
    let template = '';
    for (const nodeName of components) {
        const attributes = miniComponents[nodeName];
        template += buildComponentTemplate({ nodeName, attributes }, level, supportRecursive, supportXS);
    }
    template += buildPlainTextTemplate(level);
    template += buildThirdPartyTemplate(level, supportRecursive);
    template += buildContainerTemplate(level, restart);
    return template;
}
function buildThirdPartyAttr(attrs) {
    return [...attrs].reduce((str, attr) => {
        if (attr.startsWith('@')) { // vue event
            if (adapters_1.Adapter.type === helper_1.PLATFORMS.ALIPAY) {
                return str + `on${shared_1.capitalize(attr.slice(1))}="eh" `;
            }
            return str + `bind${attr.slice(1)}="eh" `;
        }
        else if (attr.startsWith('bind')) {
            return str + `${attr}="eh" `;
        }
        else if (attr.startsWith('on')) {
            if (adapters_1.Adapter.type === helper_1.PLATFORMS.ALIPAY) {
                return str + `${attr}="eh" `;
            }
            return str + `bind${attr.slice(2).toLowerCase()}="eh" `;
        }
        return str + `${attr}="{{ i.${shared_1.toCamelCase(attr)} }}" `;
    }, '');
}
function buildThirdPartyTemplate(level, supportRecursive) {
    const nextLevel = supportRecursive ? 0 : level + 1;
    let template = '';
    for (const [compName, attrs] of component_1.componentConfig.thirdPartyComponents) {
        template += `
<template name="tmpl_${level}_${compName}">
  <${compName} ${buildThirdPartyAttr(attrs)} id="{{ i.uid }}">
    <block ${adapters_1.Adapter.for}="{{i.${"cn" /* Childnodes */}}}" ${adapters_1.Adapter.key}="id">
      <template is="tmpl_${nextLevel}_${"container" /* Container */}" data="{{${dataKeymap('i: item')}}}" />
    </block>
  </${compName}>
</template>
`;
    }
    return template;
}
function buildBaseTemplate(maxLevel, supportRecursive, supportXS) {
    let template = `${buildXsTemplate()}
<template name="taro_tmpl">
  <block ${adapters_1.Adapter.for}="{{root.cn}}" ${adapters_1.Adapter.key}="id">
    <template is="tmpl_0_${"container" /* Container */}" data="{{${dataKeymap('i: item')}}}" />
  </block>
</template>
`;
    if (supportRecursive) {
        template += buildTemplate(0, supportRecursive, supportXS);
    }
    else {
        for (let i = 0; i < maxLevel; i++) {
            template += buildTemplate(i, supportRecursive, supportXS, maxLevel === i + 1);
        }
    }
    return template;
}
exports.buildBaseTemplate = buildBaseTemplate;
function buildPageTemplate(baseTempPath) {
    const template = `<import src="${baseTempPath}"/>
<template is="taro_tmpl" data="{{${dataKeymap('root: root')}}}" />`;
    return template;
}
exports.buildPageTemplate = buildPageTemplate;
function buildBaseComponentTemplate() {
    return `<import src="./base.wxml" />
<template is="tmpl_0_container" data="{{${dataKeymap('i: i')}}}" />`;
}
exports.buildBaseComponentTemplate = buildBaseComponentTemplate;
//# sourceMappingURL=index.js.map